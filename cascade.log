*** BEGIN @ 0
*** PARSE @ 0
(*__std = "logic",__loc = "local",__target = "sw"*) 
module Root();
	localparam STDIN = 32'h80000000;
	localparam STDOUT = 32'h80000001;
	localparam STDERR = 32'h80000002;
	localparam STDWARN = 32'h80000003;
	localparam STDINFO = 32'h80000004;
	localparam STDLOG = 32'h80000005;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "clock",__loc = "local",__target = "sw"*) 
module Clock(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "reset"*) 
module Reset(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "pad"*) 
module Pad(val);
	parameter WIDTH = 4;
	output wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "led"*) 
module Led(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "gpio"*) 
module Gpio(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__target = "sw;f1"*) 
Root root();
*** ITEM_OK @ 0
*** PARSE @ 0
Clock clock();
*** ITEM_OK @ 0
*** PARSE @ 0
module Alu(ctrl,op1,op2,zero,result);
	input wire[3:0] ctrl;
	input wire[31:0] op1;
	input wire[31:0] op2;
	output wire zero;
	output reg[31:0] result;
	always @* begin
		case (ctrl)
			4'b0000: result = (op1 << op2);
			4'b0001: result = (op1 >> op2);
			4'b0010: result = (op1 >>> op2);
			4'b0011: result = (op1 + op2);
			4'b0100: result = (op1 - op2);
			4'b0101: result = (op1 & op2);
			4'b0110: result = (op1 | op2);
			4'b0111: result = (op1 ^ op2);
			4'b1000: result = (!(op1 | op2));
			4'b1001: result = ((op1 < op2) ? 1 : 0);
			4'b1010: result = (op2 << 16);
			default: result = 0;
		endcase
	end 
	assign zero = (result == 32'b00000000000000000000000000000000);
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module AluControl(alu_op,op,ffield,ctrl);
	input wire alu_op;
	input wire[5:0] op;
	input wire[5:0] ffield;
	output reg[3:0] ctrl;
	always @* begin
		if ((alu_op == 0)) begin
			case (op)
				6'd4: ctrl = 4'b0100;
				6'd8: ctrl = 4'b0011;
				6'd10: ctrl = 4'b1001;
				6'd12: ctrl = 4'b0101;
				6'd13: ctrl = 4'b0110;
				6'd14: ctrl = 4'b0111;
				6'd15: ctrl = 4'b1010;
				6'd35: ctrl = 4'b0011;
				6'd43: ctrl = 4'b0011;
				default: ctrl = 0;
			endcase
		end 
		else begin
			case (ffield)
				6'd0: ctrl = 4'b0000;
				6'd2: ctrl = 4'b0001;
				6'd3: ctrl = 4'b0010;
				6'd6: ctrl = 4'b0001;
				6'd7: ctrl = 4'b0010;
				6'd32: ctrl = 4'b0011;
				6'd34: ctrl = 4'b0100;
				6'd36: ctrl = 4'b0101;
				6'd37: ctrl = 4'b0110;
				6'd38: ctrl = 4'b0111;
				6'd39: ctrl = 4'b1000;
				6'd42: ctrl = 4'b1001;
				default: ctrl = 0;
			endcase
		end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Control(instruction,reg_dst,jump,branch,mem_to_reg,alu_op,mem_write,alu_src,reg_write);
	input wire[31:0] instruction;
	output reg reg_dst;
	output reg jump;
	output reg branch;
	output reg mem_to_reg;
	output reg alu_op;
	output reg mem_write;
	output reg[1:0] alu_src;
	output reg reg_write;
	always @* begin
		case (instruction[31:26])
			6'd0: begin
				if ((instruction[5:0] == 6'd13)) begin
					reg_dst = 0;
					jump = 0;
					branch = 0;
					mem_to_reg = 0;
					alu_op = 0;
					mem_write = 0;
					alu_src = 2'b00;
					reg_write = 0;
				end 
				else 
					if ((instruction[5:0] < 6'd4)) begin
						reg_dst = 1;
						jump = 0;
						branch = 0;
						mem_to_reg = 0;
						alu_op = 1;
						mem_write = 0;
						alu_src = 2'b10;
						reg_write = 1;
					end 
					else 
						if ((instruction[5:0] < 6'd8)) begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b11;
							reg_write = 1;
						end 
						else begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b00;
							reg_write = 1;
						end 
			end 
			6'd2: begin
				reg_dst = 0;
				jump = 1;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd4: begin
				reg_dst = 0;
				jump = 0;
				branch = 1;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd8: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd10: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd12: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd13: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd14: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd15: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd35: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 1;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd43: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 1;
				alu_src = 2'b01;
				reg_write = 0;
			end 
			default: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
		endcase
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mem(clock,wen,raddr1,rdata1,raddr2,rdata2,waddr,wdata);
	parameter ADDR_SIZE = 4;
	parameter BYTE_SIZE = 8;
	input wire clock;
	input wire wen;
	input wire[(ADDR_SIZE - 1):0] raddr1;
	output wire[(BYTE_SIZE - 1):0] rdata1;
	input wire[(ADDR_SIZE - 1):0] raddr2;
	output wire[(BYTE_SIZE - 1):0] rdata2;
	input wire[(ADDR_SIZE - 1):0] waddr;
	input wire[(BYTE_SIZE - 1):0] wdata;
	reg[(BYTE_SIZE - 1):0] mem[((2 ** ADDR_SIZE) - 1):0];
	assign rdata1 = mem[raddr1];
	assign rdata2 = mem[raddr2];
	always @(posedge clock) if (wen) 
		mem[waddr] <= wdata;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mips32(instr,raddr);
	input wire[31:0] instr;
	output wire[31:0] raddr;
	reg[31:0] pc = 0;
	wire[31:0] pc_4;
	assign pc_4 = (pc + 4);
	assign raddr = (pc >> 2);
	wire reg_dst;
	wire jump;
	wire branch;
	wire mem_to_reg;
	wire alu_op;
	wire mem_write;
	wire[1:0] alu_src;
	wire c_reg_write;
	Control control(.instruction(instr),.reg_dst(reg_dst),.jump(jump),.branch(branch),.mem_to_reg(mem_to_reg),.alu_op(alu_op),.mem_write(mem_write),.alu_src(alu_src),.reg_write(c_reg_write));
	wire[4:0] shamt;
	assign shamt = instr[10:6];
	wire[31:0] imm;
	assign imm = {(instr[15] ? 16'b0000000000000001 : 16'b0000000000000000),instr[15:0]};
	wire[31:0] jump_addr;
	assign jump_addr = {pc_4[31:28],instr[25:0],2'b00};
	wire[31:0] branch_addr;
	assign branch_addr = (pc_4 + (imm << 2));
	wire[31:0] reg_read1;
	wire[31:0] reg_read2;
	wire[31:0] reg_write;
	Mem #(5,32) regs(.clock(clock.val),.wen(c_reg_write),.raddr1(instr[25:21]),.rdata1(reg_read1),.raddr2(instr[20:16]),.rdata2(reg_read2),.waddr((reg_dst ? instr[15:11] : instr[20:16])),.wdata(reg_write));
	wire[3:0] ctrl;
	AluControl alu_control(.alu_op(alu_op),.op(instr[31:26]),.ffield(instr[5:0]),.ctrl(ctrl));
	wire zero;
	wire[31:0] result;
	Alu alu(.ctrl(ctrl),.op1((alu_src[1] ? reg_read2 : reg_read1)),.op2((alu_src[1] ? (alu_src[0] ? reg_read1 : shamt) : (alu_src[0] ? imm : reg_read2))),.zero(zero),.result(result));
	wire[31:0] mem_read;
	Mem #(7,32) dmem(.clock(clock.val),.wen(mem_write),.raddr1((result >> 2)),.rdata1(mem_read),.waddr((result >> 2)),.wdata(reg_read2));
	assign reg_write = (mem_to_reg ? mem_read : result);
	always @(posedge clock.val) begin
		if ((instr[5:0] == 6'd13)) begin
			begin
				$__put(STDOUT,"%_",reg_read1);
				$fflush(STDOUT);
			end 
			$finish(0);
		end 
		if (jump) begin
			pc <= jump_addr;
		end 
		else 
			if ((branch & zero)) begin
				pc <= branch_addr;
			end 
			else begin
				pc <= pc_4;
			end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
reg[31:0] imem[63:0];
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] s = $fopen("share/cascade/test/benchmark/mips32/run_bubble_128_1024.hex","r");
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] i = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
reg[31:0] val = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
initial begin
	for (i = 0; (i < 63); i = (i + 1)) begin
		$__get(s,"%u",val);
		imem[i] <= val;
	end 
end 
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] addr;
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] instr;
*** ITEM_OK @ 0
*** PARSE @ 0
assign instr = imem[addr];
*** ITEM_OK @ 0
*** PARSE @ 0
Mips32 mips32(.instr(instr),.raddr(addr));
*** ITEM_OK @ 0
*** BEGIN @ 0
*** PARSE @ 0
(*__std = "logic",__loc = "local",__target = "sw"*) 
module Root();
	localparam STDIN = 32'h80000000;
	localparam STDOUT = 32'h80000001;
	localparam STDERR = 32'h80000002;
	localparam STDWARN = 32'h80000003;
	localparam STDINFO = 32'h80000004;
	localparam STDLOG = 32'h80000005;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "clock",__loc = "local",__target = "sw"*) 
module Clock(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "reset"*) 
module Reset(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "pad"*) 
module Pad(val);
	parameter WIDTH = 4;
	output wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "led"*) 
module Led(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "gpio"*) 
module Gpio(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__target = "sw;f1"*) 
Root root();
*** ITEM_OK @ 0
*** PARSE @ 0
Clock clock();
*** ITEM_OK @ 0
*** PARSE @ 0
module Alu(ctrl,op1,op2,zero,result);
	input wire[3:0] ctrl;
	input wire[31:0] op1;
	input wire[31:0] op2;
	output wire zero;
	output reg[31:0] result;
	always @* begin
		case (ctrl)
			4'b0000: result = (op1 << op2);
			4'b0001: result = (op1 >> op2);
			4'b0010: result = (op1 >>> op2);
			4'b0011: result = (op1 + op2);
			4'b0100: result = (op1 - op2);
			4'b0101: result = (op1 & op2);
			4'b0110: result = (op1 | op2);
			4'b0111: result = (op1 ^ op2);
			4'b1000: result = (!(op1 | op2));
			4'b1001: result = ((op1 < op2) ? 1 : 0);
			4'b1010: result = (op2 << 16);
			default: result = 0;
		endcase
	end 
	assign zero = (result == 32'b00000000000000000000000000000000);
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module AluControl(alu_op,op,ffield,ctrl);
	input wire alu_op;
	input wire[5:0] op;
	input wire[5:0] ffield;
	output reg[3:0] ctrl;
	always @* begin
		if ((alu_op == 0)) begin
			case (op)
				6'd4: ctrl = 4'b0100;
				6'd8: ctrl = 4'b0011;
				6'd10: ctrl = 4'b1001;
				6'd12: ctrl = 4'b0101;
				6'd13: ctrl = 4'b0110;
				6'd14: ctrl = 4'b0111;
				6'd15: ctrl = 4'b1010;
				6'd35: ctrl = 4'b0011;
				6'd43: ctrl = 4'b0011;
				default: ctrl = 0;
			endcase
		end 
		else begin
			case (ffield)
				6'd0: ctrl = 4'b0000;
				6'd2: ctrl = 4'b0001;
				6'd3: ctrl = 4'b0010;
				6'd6: ctrl = 4'b0001;
				6'd7: ctrl = 4'b0010;
				6'd32: ctrl = 4'b0011;
				6'd34: ctrl = 4'b0100;
				6'd36: ctrl = 4'b0101;
				6'd37: ctrl = 4'b0110;
				6'd38: ctrl = 4'b0111;
				6'd39: ctrl = 4'b1000;
				6'd42: ctrl = 4'b1001;
				default: ctrl = 0;
			endcase
		end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Control(instruction,reg_dst,jump,branch,mem_to_reg,alu_op,mem_write,alu_src,reg_write);
	input wire[31:0] instruction;
	output reg reg_dst;
	output reg jump;
	output reg branch;
	output reg mem_to_reg;
	output reg alu_op;
	output reg mem_write;
	output reg[1:0] alu_src;
	output reg reg_write;
	always @* begin
		case (instruction[31:26])
			6'd0: begin
				if ((instruction[5:0] == 6'd13)) begin
					reg_dst = 0;
					jump = 0;
					branch = 0;
					mem_to_reg = 0;
					alu_op = 0;
					mem_write = 0;
					alu_src = 2'b00;
					reg_write = 0;
				end 
				else 
					if ((instruction[5:0] < 6'd4)) begin
						reg_dst = 1;
						jump = 0;
						branch = 0;
						mem_to_reg = 0;
						alu_op = 1;
						mem_write = 0;
						alu_src = 2'b10;
						reg_write = 1;
					end 
					else 
						if ((instruction[5:0] < 6'd8)) begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b11;
							reg_write = 1;
						end 
						else begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b00;
							reg_write = 1;
						end 
			end 
			6'd2: begin
				reg_dst = 0;
				jump = 1;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd4: begin
				reg_dst = 0;
				jump = 0;
				branch = 1;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd8: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd10: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd12: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd13: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd14: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd15: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd35: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 1;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd43: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 1;
				alu_src = 2'b01;
				reg_write = 0;
			end 
			default: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
		endcase
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mem(clock,wen,raddr1,rdata1,raddr2,rdata2,waddr,wdata);
	parameter ADDR_SIZE = 4;
	parameter BYTE_SIZE = 8;
	input wire clock;
	input wire wen;
	input wire[(ADDR_SIZE - 1):0] raddr1;
	output wire[(BYTE_SIZE - 1):0] rdata1;
	input wire[(ADDR_SIZE - 1):0] raddr2;
	output wire[(BYTE_SIZE - 1):0] rdata2;
	input wire[(ADDR_SIZE - 1):0] waddr;
	input wire[(BYTE_SIZE - 1):0] wdata;
	reg[(BYTE_SIZE - 1):0] mem[((2 ** ADDR_SIZE) - 1):0];
	assign rdata1 = mem[raddr1];
	assign rdata2 = mem[raddr2];
	always @(posedge clock) if (wen) 
		mem[waddr] <= wdata;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mips32Yield(instr,raddr);
	input wire[31:0] instr;
	output wire[31:0] raddr;
	(*non_volatile*) reg[31:0] pc = 0;
	wire[31:0] pc_4;
	assign pc_4 = (pc + 4);
	assign raddr = (pc >> 2);
	wire reg_dst;
	wire jump;
	wire branch;
	wire mem_to_reg;
	wire alu_op;
	wire mem_write;
	wire[1:0] alu_src;
	wire c_reg_write;
	Control control(.instruction(instr),.reg_dst(reg_dst),.jump(jump),.branch(branch),.mem_to_reg(mem_to_reg),.alu_op(alu_op),.mem_write(mem_write),.alu_src(alu_src),.reg_write(c_reg_write));
	wire[4:0] shamt;
	assign shamt = instr[10:6];
	wire[31:0] imm;
	assign imm = {(instr[15] ? 16'b0000000000000001 : 16'b0000000000000000),instr[15:0]};
	wire[31:0] jump_addr;
	assign jump_addr = {pc_4[31:28],instr[25:0],2'b00};
	wire[31:0] branch_addr;
	assign branch_addr = (pc_4 + (imm << 2));
	wire[31:0] reg_read1;
	wire[31:0] reg_read2;
	wire[31:0] reg_write;
	Mem #(5,32) regs(.clock(clock.val),.wen(c_reg_write),.raddr1(instr[25:21]),.rdata1(reg_read1),.raddr2(instr[20:16]),.rdata2(reg_read2),.waddr((reg_dst ? instr[15:11] : instr[20:16])),.wdata(reg_write));
	wire[3:0] ctrl;
	AluControl alu_control(.alu_op(alu_op),.op(instr[31:26]),.ffield(instr[5:0]),.ctrl(ctrl));
	wire zero;
	wire[31:0] result;
	Alu alu(.ctrl(ctrl),.op1((alu_src[1] ? reg_read2 : reg_read1)),.op2((alu_src[1] ? (alu_src[0] ? reg_read1 : shamt) : (alu_src[0] ? imm : reg_read2))),.zero(zero),.result(result));
	wire[31:0] mem_read;
	Mem #(7,32) dmem(.clock(clock.val),.wen(mem_write),.raddr1((result >> 2)),.rdata1(mem_read),.waddr((result >> 2)),.wdata(reg_read2));
	assign reg_write = (mem_to_reg ? mem_read : result);
	always @(posedge clock.val) begin
		if ((instr[5:0] == 6'd13)) begin
			begin
				$__put(STDOUT,"%_",reg_read1);
				$fflush(STDOUT);
			end 
			$finish(0);
		end 
		if ((instr == 32'h114b0001)) begin
			$yield();
		end 
		if (jump) begin
			pc <= jump_addr;
		end 
		else 
			if ((branch & zero)) begin
				pc <= branch_addr;
			end 
			else begin
				pc <= pc_4;
			end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*non_volatile*) reg[31:0] imem[63:0];
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] s = $fopen("share/cascade/test/benchmark/mips32/run_bubble_128_1024.hex","r");
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] i = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
reg[31:0] val = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
initial begin
	for (i = 0; (i < 63); i = (i + 1)) begin
		$__get(s,"%u",val);
		imem[i] <= val;
	end 
end 
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] addr;
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] instr;
*** ITEM_OK @ 0
*** PARSE @ 0
assign instr = imem[addr];
*** ITEM_OK @ 0
*** PARSE @ 0
Mips32Yield mips32(.instr(instr),.raddr(addr));
*** ITEM_OK @ 0
*** BEGIN @ 0
*** PARSE @ 0
(*__std = "logic",__loc = "local",__target = "sw"*) 
module Root();
	localparam STDIN = 32'h80000000;
	localparam STDOUT = 32'h80000001;
	localparam STDERR = 32'h80000002;
	localparam STDWARN = 32'h80000003;
	localparam STDINFO = 32'h80000004;
	localparam STDLOG = 32'h80000005;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "clock",__loc = "local",__target = "sw"*) 
module Clock(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "reset"*) 
module Reset(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "pad"*) 
module Pad(val);
	parameter WIDTH = 4;
	output wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "led"*) 
module Led(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "gpio"*) 
module Gpio(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__target = "sw;f1"*) 
Root root();
*** ITEM_OK @ 0
*** PARSE @ 0
Clock clock();
*** ITEM_OK @ 0
*** PARSE @ 0
module Alu(ctrl,op1,op2,zero,result);
	input wire[3:0] ctrl;
	input wire[31:0] op1;
	input wire[31:0] op2;
	output wire zero;
	output reg[31:0] result;
	always @* begin
		case (ctrl)
			4'b0000: result = (op1 << op2);
			4'b0001: result = (op1 >> op2);
			4'b0010: result = (op1 >>> op2);
			4'b0011: result = (op1 + op2);
			4'b0100: result = (op1 - op2);
			4'b0101: result = (op1 & op2);
			4'b0110: result = (op1 | op2);
			4'b0111: result = (op1 ^ op2);
			4'b1000: result = (!(op1 | op2));
			4'b1001: result = ((op1 < op2) ? 1 : 0);
			4'b1010: result = (op2 << 16);
			default: result = 0;
		endcase
	end 
	assign zero = (result == 32'b00000000000000000000000000000000);
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module AluControl(alu_op,op,ffield,ctrl);
	input wire alu_op;
	input wire[5:0] op;
	input wire[5:0] ffield;
	output reg[3:0] ctrl;
	always @* begin
		if ((alu_op == 0)) begin
			case (op)
				6'd4: ctrl = 4'b0100;
				6'd8: ctrl = 4'b0011;
				6'd10: ctrl = 4'b1001;
				6'd12: ctrl = 4'b0101;
				6'd13: ctrl = 4'b0110;
				6'd14: ctrl = 4'b0111;
				6'd15: ctrl = 4'b1010;
				6'd35: ctrl = 4'b0011;
				6'd43: ctrl = 4'b0011;
				default: ctrl = 0;
			endcase
		end 
		else begin
			case (ffield)
				6'd0: ctrl = 4'b0000;
				6'd2: ctrl = 4'b0001;
				6'd3: ctrl = 4'b0010;
				6'd6: ctrl = 4'b0001;
				6'd7: ctrl = 4'b0010;
				6'd32: ctrl = 4'b0011;
				6'd34: ctrl = 4'b0100;
				6'd36: ctrl = 4'b0101;
				6'd37: ctrl = 4'b0110;
				6'd38: ctrl = 4'b0111;
				6'd39: ctrl = 4'b1000;
				6'd42: ctrl = 4'b1001;
				default: ctrl = 0;
			endcase
		end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Control(instruction,reg_dst,jump,branch,mem_to_reg,alu_op,mem_write,alu_src,reg_write);
	input wire[31:0] instruction;
	output reg reg_dst;
	output reg jump;
	output reg branch;
	output reg mem_to_reg;
	output reg alu_op;
	output reg mem_write;
	output reg[1:0] alu_src;
	output reg reg_write;
	always @* begin
		case (instruction[31:26])
			6'd0: begin
				if ((instruction[5:0] == 6'd13)) begin
					reg_dst = 0;
					jump = 0;
					branch = 0;
					mem_to_reg = 0;
					alu_op = 0;
					mem_write = 0;
					alu_src = 2'b00;
					reg_write = 0;
				end 
				else 
					if ((instruction[5:0] < 6'd4)) begin
						reg_dst = 1;
						jump = 0;
						branch = 0;
						mem_to_reg = 0;
						alu_op = 1;
						mem_write = 0;
						alu_src = 2'b10;
						reg_write = 1;
					end 
					else 
						if ((instruction[5:0] < 6'd8)) begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b11;
							reg_write = 1;
						end 
						else begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b00;
							reg_write = 1;
						end 
			end 
			6'd2: begin
				reg_dst = 0;
				jump = 1;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd4: begin
				reg_dst = 0;
				jump = 0;
				branch = 1;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd8: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd10: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd12: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd13: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd14: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd15: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd35: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 1;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd43: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 1;
				alu_src = 2'b01;
				reg_write = 0;
			end 
			default: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
		endcase
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mem(clock,wen,raddr1,rdata1,raddr2,rdata2,waddr,wdata);
	parameter ADDR_SIZE = 4;
	parameter BYTE_SIZE = 8;
	input wire clock;
	input wire wen;
	input wire[(ADDR_SIZE - 1):0] raddr1;
	output wire[(BYTE_SIZE - 1):0] rdata1;
	input wire[(ADDR_SIZE - 1):0] raddr2;
	output wire[(BYTE_SIZE - 1):0] rdata2;
	input wire[(ADDR_SIZE - 1):0] waddr;
	input wire[(BYTE_SIZE - 1):0] wdata;
	reg[(BYTE_SIZE - 1):0] mem[((2 ** ADDR_SIZE) - 1):0];
	assign rdata1 = mem[raddr1];
	assign rdata2 = mem[raddr2];
	always @(posedge clock) if (wen) 
		mem[waddr] <= wdata;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mips32Yield(instr,raddr);
	input wire[31:0] instr;
	output wire[31:0] raddr;
	(*non_volatile*) reg[31:0] pc = 0;
	wire[31:0] pc_4;
	assign pc_4 = (pc + 4);
	assign raddr = (pc >> 2);
	wire reg_dst;
	wire jump;
	wire branch;
	wire mem_to_reg;
	wire alu_op;
	wire mem_write;
	wire[1:0] alu_src;
	wire c_reg_write;
	Control control(.instruction(instr),.reg_dst(reg_dst),.jump(jump),.branch(branch),.mem_to_reg(mem_to_reg),.alu_op(alu_op),.mem_write(mem_write),.alu_src(alu_src),.reg_write(c_reg_write));
	wire[4:0] shamt;
	assign shamt = instr[10:6];
	wire[31:0] imm;
	assign imm = {(instr[15] ? 16'b0000000000000001 : 16'b0000000000000000),instr[15:0]};
	wire[31:0] jump_addr;
	assign jump_addr = {pc_4[31:28],instr[25:0],2'b00};
	wire[31:0] branch_addr;
	assign branch_addr = (pc_4 + (imm << 2));
	wire[31:0] reg_read1;
	wire[31:0] reg_read2;
	wire[31:0] reg_write;
	Mem #(5,32) regs(.clock(clock.val),.wen(c_reg_write),.raddr1(instr[25:21]),.rdata1(reg_read1),.raddr2(instr[20:16]),.rdata2(reg_read2),.waddr((reg_dst ? instr[15:11] : instr[20:16])),.wdata(reg_write));
	wire[3:0] ctrl;
	AluControl alu_control(.alu_op(alu_op),.op(instr[31:26]),.ffield(instr[5:0]),.ctrl(ctrl));
	wire zero;
	wire[31:0] result;
	Alu alu(.ctrl(ctrl),.op1((alu_src[1] ? reg_read2 : reg_read1)),.op2((alu_src[1] ? (alu_src[0] ? reg_read1 : shamt) : (alu_src[0] ? imm : reg_read2))),.zero(zero),.result(result));
	wire[31:0] mem_read;
	Mem #(7,32) dmem(.clock(clock.val),.wen(mem_write),.raddr1((result >> 2)),.rdata1(mem_read),.waddr((result >> 2)),.wdata(reg_read2));
	assign reg_write = (mem_to_reg ? mem_read : result);
	always @(posedge clock.val) begin
		if ((instr[5:0] == 6'd13)) begin
			begin
				$__put(STDOUT,"%_",reg_read1);
				$fflush(STDOUT);
			end 
			$finish(0);
		end 
		if ((instr == 32'h114b0001)) begin
			$yield();
		end 
		if (jump) begin
			pc <= jump_addr;
		end 
		else 
			if ((branch & zero)) begin
				pc <= branch_addr;
			end 
			else begin
				pc <= pc_4;
			end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*non_volatile*) reg[31:0] imem[63:0];
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] s = $fopen("share/cascade/test/benchmark/mips32/run_bubble_128_1024.hex","r");
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] i = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
reg[31:0] val = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
initial begin
	for (i = 0; (i < 63); i = (i + 1)) begin
		$__get(s,"%u",val);
		imem[i] <= val;
	end 
end 
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] addr;
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] instr;
*** ITEM_OK @ 0
*** PARSE @ 0
assign instr = imem[addr];
*** ITEM_OK @ 0
*** PARSE @ 0
Mips32Yield mips32(.instr(instr),.raddr(addr));
*** ITEM_OK @ 0
*** BEGIN @ 0
*** PARSE @ 0
(*__std = "logic",__loc = "local",__target = "sw"*) 
module Root();
	localparam STDIN = 32'h80000000;
	localparam STDOUT = 32'h80000001;
	localparam STDERR = 32'h80000002;
	localparam STDWARN = 32'h80000003;
	localparam STDINFO = 32'h80000004;
	localparam STDLOG = 32'h80000005;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "clock",__loc = "local",__target = "sw"*) 
module Clock(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "reset"*) 
module Reset(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "pad"*) 
module Pad(val);
	parameter WIDTH = 4;
	output wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "led"*) 
module Led(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "gpio"*) 
module Gpio(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__target = "sw;f1"*) 
Root root();
*** ITEM_OK @ 0
*** PARSE @ 0
Clock clock();
*** ITEM_OK @ 0
*** PARSE @ 0
module Alu(ctrl,op1,op2,zero,result);
	input wire[3:0] ctrl;
	input wire[31:0] op1;
	input wire[31:0] op2;
	output wire zero;
	output reg[31:0] result;
	always @* begin
		case (ctrl)
			4'b0000: result = (op1 << op2);
			4'b0001: result = (op1 >> op2);
			4'b0010: result = (op1 >>> op2);
			4'b0011: result = (op1 + op2);
			4'b0100: result = (op1 - op2);
			4'b0101: result = (op1 & op2);
			4'b0110: result = (op1 | op2);
			4'b0111: result = (op1 ^ op2);
			4'b1000: result = (!(op1 | op2));
			4'b1001: result = ((op1 < op2) ? 1 : 0);
			4'b1010: result = (op2 << 16);
			default: result = 0;
		endcase
	end 
	assign zero = (result == 32'b00000000000000000000000000000000);
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module AluControl(alu_op,op,ffield,ctrl);
	input wire alu_op;
	input wire[5:0] op;
	input wire[5:0] ffield;
	output reg[3:0] ctrl;
	always @* begin
		if ((alu_op == 0)) begin
			case (op)
				6'd4: ctrl = 4'b0100;
				6'd8: ctrl = 4'b0011;
				6'd10: ctrl = 4'b1001;
				6'd12: ctrl = 4'b0101;
				6'd13: ctrl = 4'b0110;
				6'd14: ctrl = 4'b0111;
				6'd15: ctrl = 4'b1010;
				6'd35: ctrl = 4'b0011;
				6'd43: ctrl = 4'b0011;
				default: ctrl = 0;
			endcase
		end 
		else begin
			case (ffield)
				6'd0: ctrl = 4'b0000;
				6'd2: ctrl = 4'b0001;
				6'd3: ctrl = 4'b0010;
				6'd6: ctrl = 4'b0001;
				6'd7: ctrl = 4'b0010;
				6'd32: ctrl = 4'b0011;
				6'd34: ctrl = 4'b0100;
				6'd36: ctrl = 4'b0101;
				6'd37: ctrl = 4'b0110;
				6'd38: ctrl = 4'b0111;
				6'd39: ctrl = 4'b1000;
				6'd42: ctrl = 4'b1001;
				default: ctrl = 0;
			endcase
		end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Control(instruction,reg_dst,jump,branch,mem_to_reg,alu_op,mem_write,alu_src,reg_write);
	input wire[31:0] instruction;
	output reg reg_dst;
	output reg jump;
	output reg branch;
	output reg mem_to_reg;
	output reg alu_op;
	output reg mem_write;
	output reg[1:0] alu_src;
	output reg reg_write;
	always @* begin
		case (instruction[31:26])
			6'd0: begin
				if ((instruction[5:0] == 6'd13)) begin
					reg_dst = 0;
					jump = 0;
					branch = 0;
					mem_to_reg = 0;
					alu_op = 0;
					mem_write = 0;
					alu_src = 2'b00;
					reg_write = 0;
				end 
				else 
					if ((instruction[5:0] < 6'd4)) begin
						reg_dst = 1;
						jump = 0;
						branch = 0;
						mem_to_reg = 0;
						alu_op = 1;
						mem_write = 0;
						alu_src = 2'b10;
						reg_write = 1;
					end 
					else 
						if ((instruction[5:0] < 6'd8)) begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b11;
							reg_write = 1;
						end 
						else begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b00;
							reg_write = 1;
						end 
			end 
			6'd2: begin
				reg_dst = 0;
				jump = 1;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd4: begin
				reg_dst = 0;
				jump = 0;
				branch = 1;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd8: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd10: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd12: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd13: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd14: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd15: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd35: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 1;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd43: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 1;
				alu_src = 2'b01;
				reg_write = 0;
			end 
			default: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
		endcase
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mem(clock,wen,raddr1,rdata1,raddr2,rdata2,waddr,wdata);
	parameter ADDR_SIZE = 4;
	parameter BYTE_SIZE = 8;
	input wire clock;
	input wire wen;
	input wire[(ADDR_SIZE - 1):0] raddr1;
	output wire[(BYTE_SIZE - 1):0] rdata1;
	input wire[(ADDR_SIZE - 1):0] raddr2;
	output wire[(BYTE_SIZE - 1):0] rdata2;
	input wire[(ADDR_SIZE - 1):0] waddr;
	input wire[(BYTE_SIZE - 1):0] wdata;
	reg[(BYTE_SIZE - 1):0] mem[((2 ** ADDR_SIZE) - 1):0];
	assign rdata1 = mem[raddr1];
	assign rdata2 = mem[raddr2];
	always @(posedge clock) if (wen) 
		mem[waddr] <= wdata;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mips32Yield(instr,raddr);
	input wire[31:0] instr;
	output wire[31:0] raddr;
	(*non_volatile*) reg[31:0] pc = 0;
	wire[31:0] pc_4;
	assign pc_4 = (pc + 4);
	assign raddr = (pc >> 2);
	wire reg_dst;
	wire jump;
	wire branch;
	wire mem_to_reg;
	wire alu_op;
	wire mem_write;
	wire[1:0] alu_src;
	wire c_reg_write;
	Control control(.instruction(instr),.reg_dst(reg_dst),.jump(jump),.branch(branch),.mem_to_reg(mem_to_reg),.alu_op(alu_op),.mem_write(mem_write),.alu_src(alu_src),.reg_write(c_reg_write));
	wire[4:0] shamt;
	assign shamt = instr[10:6];
	wire[31:0] imm;
	assign imm = {(instr[15] ? 16'b0000000000000001 : 16'b0000000000000000),instr[15:0]};
	wire[31:0] jump_addr;
	assign jump_addr = {pc_4[31:28],instr[25:0],2'b00};
	wire[31:0] branch_addr;
	assign branch_addr = (pc_4 + (imm << 2));
	wire[31:0] reg_read1;
	wire[31:0] reg_read2;
	wire[31:0] reg_write;
	Mem #(5,32) regs(.clock(clock.val),.wen(c_reg_write),.raddr1(instr[25:21]),.rdata1(reg_read1),.raddr2(instr[20:16]),.rdata2(reg_read2),.waddr((reg_dst ? instr[15:11] : instr[20:16])),.wdata(reg_write));
	wire[3:0] ctrl;
	AluControl alu_control(.alu_op(alu_op),.op(instr[31:26]),.ffield(instr[5:0]),.ctrl(ctrl));
	wire zero;
	wire[31:0] result;
	Alu alu(.ctrl(ctrl),.op1((alu_src[1] ? reg_read2 : reg_read1)),.op2((alu_src[1] ? (alu_src[0] ? reg_read1 : shamt) : (alu_src[0] ? imm : reg_read2))),.zero(zero),.result(result));
	wire[31:0] mem_read;
	Mem #(7,32) dmem(.clock(clock.val),.wen(mem_write),.raddr1((result >> 2)),.rdata1(mem_read),.waddr((result >> 2)),.wdata(reg_read2));
	assign reg_write = (mem_to_reg ? mem_read : result);
	always @(posedge clock.val) begin
		if ((instr[5:0] == 6'd13)) begin
			begin
				$__put(STDOUT,"%_",reg_read1);
				$fflush(STDOUT);
			end 
			$finish(0);
		end 
		if ((instr == 32'h114b0001)) begin
			$yield();
		end 
		if (jump) begin
			pc <= jump_addr;
		end 
		else 
			if ((branch & zero)) begin
				pc <= branch_addr;
			end 
			else begin
				pc <= pc_4;
			end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*non_volatile*) reg[31:0] imem[63:0];
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] s = $fopen("share/cascade/test/benchmark/mips32/run_bubble_128_1024.hex","r");
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] i = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
reg[31:0] val = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
initial begin
	for (i = 0; (i < 63); i = (i + 1)) begin
		$__get(s,"%u",val);
		imem[i] <= val;
	end 
end 
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] addr;
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] instr;
*** ITEM_OK @ 0
*** PARSE @ 0
assign instr = imem[addr];
*** ITEM_OK @ 0
*** PARSE @ 0
Mips32Yield mips32(.instr(instr),.raddr(addr));
*** ITEM_OK @ 0
*** BEGIN @ 0
*** PARSE @ 1517
(*__std = "logic",__loc = "local",__target = "sw"*) 
module Root();
	localparam STDIN = 32'h80000000;
	localparam STDOUT = 32'h80000001;
	localparam STDERR = 32'h80000002;
	localparam STDWARN = 32'h80000003;
	localparam STDINFO = 32'h80000004;
	localparam STDLOG = 32'h80000005;
endmodule
*** DECL_OK @ 1517
*** PARSE @ 1517
(*__std = "clock",__loc = "local",__target = "sw"*) 
module Clock(val);
	output wire val;
endmodule
*** DECL_OK @ 1517
*** PARSE @ 1517
(*__std = "reset"*) 
module Reset(val);
	output wire val;
endmodule
*** DECL_OK @ 1517
*** PARSE @ 1517
(*__std = "pad"*) 
module Pad(val);
	parameter WIDTH = 4;
	output wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 1517
*** PARSE @ 1517
(*__std = "led"*) 
module Led(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 1517
*** PARSE @ 1517
(*__std = "gpio"*) 
module Gpio(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 1517
*** PARSE @ 1517
(*__target = "sw;f1"*) 
Root root();
*** ITEM_OK @ 1517
*** PARSE @ 1517
Clock clock();
*** ITEM_OK @ 1517
*** PARSE @ 1517
module Alu(ctrl,op1,op2,zero,result);
	input wire[3:0] ctrl;
	input wire[31:0] op1;
	input wire[31:0] op2;
	output wire zero;
	output reg[31:0] result;
	always @* begin
		case (ctrl)
			4'b0000: result = (op1 << op2);
			4'b0001: result = (op1 >> op2);
			4'b0010: result = (op1 >>> op2);
			4'b0011: result = (op1 + op2);
			4'b0100: result = (op1 - op2);
			4'b0101: result = (op1 & op2);
			4'b0110: result = (op1 | op2);
			4'b0111: result = (op1 ^ op2);
			4'b1000: result = (!(op1 | op2));
			4'b1001: result = ((op1 < op2) ? 1 : 0);
			4'b1010: result = (op2 << 16);
			default: result = 0;
		endcase
	end 
	assign zero = (result == 32'b00000000000000000000000000000000);
endmodule
*** DECL_OK @ 1517
*** PARSE @ 1517
module AluControl(alu_op,op,ffield,ctrl);
	input wire alu_op;
	input wire[5:0] op;
	input wire[5:0] ffield;
	output reg[3:0] ctrl;
	always @* begin
		if ((alu_op == 0)) begin
			case (op)
				6'd4: ctrl = 4'b0100;
				6'd8: ctrl = 4'b0011;
				6'd10: ctrl = 4'b1001;
				6'd12: ctrl = 4'b0101;
				6'd13: ctrl = 4'b0110;
				6'd14: ctrl = 4'b0111;
				6'd15: ctrl = 4'b1010;
				6'd35: ctrl = 4'b0011;
				6'd43: ctrl = 4'b0011;
				default: ctrl = 0;
			endcase
		end 
		else begin
			case (ffield)
				6'd0: ctrl = 4'b0000;
				6'd2: ctrl = 4'b0001;
				6'd3: ctrl = 4'b0010;
				6'd6: ctrl = 4'b0001;
				6'd7: ctrl = 4'b0010;
				6'd32: ctrl = 4'b0011;
				6'd34: ctrl = 4'b0100;
				6'd36: ctrl = 4'b0101;
				6'd37: ctrl = 4'b0110;
				6'd38: ctrl = 4'b0111;
				6'd39: ctrl = 4'b1000;
				6'd42: ctrl = 4'b1001;
				default: ctrl = 0;
			endcase
		end 
	end 
endmodule
*** DECL_OK @ 1517
*** PARSE @ 1517
module Control(instruction,reg_dst,jump,branch,mem_to_reg,alu_op,mem_write,alu_src,reg_write);
	input wire[31:0] instruction;
	output reg reg_dst;
	output reg jump;
	output reg branch;
	output reg mem_to_reg;
	output reg alu_op;
	output reg mem_write;
	output reg[1:0] alu_src;
	output reg reg_write;
	always @* begin
		case (instruction[31:26])
			6'd0: begin
				if ((instruction[5:0] == 6'd13)) begin
					reg_dst = 0;
					jump = 0;
					branch = 0;
					mem_to_reg = 0;
					alu_op = 0;
					mem_write = 0;
					alu_src = 2'b00;
					reg_write = 0;
				end 
				else 
					if ((instruction[5:0] < 6'd4)) begin
						reg_dst = 1;
						jump = 0;
						branch = 0;
						mem_to_reg = 0;
						alu_op = 1;
						mem_write = 0;
						alu_src = 2'b10;
						reg_write = 1;
					end 
					else 
						if ((instruction[5:0] < 6'd8)) begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b11;
							reg_write = 1;
						end 
						else begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b00;
							reg_write = 1;
						end 
			end 
			6'd2: begin
				reg_dst = 0;
				jump = 1;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd4: begin
				reg_dst = 0;
				jump = 0;
				branch = 1;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd8: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd10: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd12: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd13: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd14: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd15: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd35: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 1;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd43: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 1;
				alu_src = 2'b01;
				reg_write = 0;
			end 
			default: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
		endcase
	end 
endmodule
*** DECL_OK @ 1517
*** PARSE @ 1517
module Mem(clock,wen,raddr1,rdata1,raddr2,rdata2,waddr,wdata);
	parameter ADDR_SIZE = 4;
	parameter BYTE_SIZE = 8;
	input wire clock;
	input wire wen;
	input wire[(ADDR_SIZE - 1):0] raddr1;
	output wire[(BYTE_SIZE - 1):0] rdata1;
	input wire[(ADDR_SIZE - 1):0] raddr2;
	output wire[(BYTE_SIZE - 1):0] rdata2;
	input wire[(ADDR_SIZE - 1):0] waddr;
	input wire[(BYTE_SIZE - 1):0] wdata;
	reg[(BYTE_SIZE - 1):0] mem[((2 ** ADDR_SIZE) - 1):0];
	assign rdata1 = mem[raddr1];
	assign rdata2 = mem[raddr2];
	always @(posedge clock) if (wen) 
		mem[waddr] <= wdata;
endmodule
*** DECL_OK @ 1517
*** PARSE @ 1517
module Mips32Yield(instr,raddr);
	input wire[31:0] instr;
	output wire[31:0] raddr;
	(*non_volatile*) reg[31:0] pc = 0;
	wire[31:0] pc_4;
	assign pc_4 = (pc + 4);
	assign raddr = (pc >> 2);
	wire reg_dst;
	wire jump;
	wire branch;
	wire mem_to_reg;
	wire alu_op;
	wire mem_write;
	wire[1:0] alu_src;
	wire c_reg_write;
	Control control(.instruction(instr),.reg_dst(reg_dst),.jump(jump),.branch(branch),.mem_to_reg(mem_to_reg),.alu_op(alu_op),.mem_write(mem_write),.alu_src(alu_src),.reg_write(c_reg_write));
	wire[4:0] shamt;
	assign shamt = instr[10:6];
	wire[31:0] imm;
	assign imm = {(instr[15] ? 16'b0000000000000001 : 16'b0000000000000000),instr[15:0]};
	wire[31:0] jump_addr;
	assign jump_addr = {pc_4[31:28],instr[25:0],2'b00};
	wire[31:0] branch_addr;
	assign branch_addr = (pc_4 + (imm << 2));
	wire[31:0] reg_read1;
	wire[31:0] reg_read2;
	wire[31:0] reg_write;
	Mem #(5,32) regs(.clock(clock.val),.wen(c_reg_write),.raddr1(instr[25:21]),.rdata1(reg_read1),.raddr2(instr[20:16]),.rdata2(reg_read2),.waddr((reg_dst ? instr[15:11] : instr[20:16])),.wdata(reg_write));
	wire[3:0] ctrl;
	AluControl alu_control(.alu_op(alu_op),.op(instr[31:26]),.ffield(instr[5:0]),.ctrl(ctrl));
	wire zero;
	wire[31:0] result;
	Alu alu(.ctrl(ctrl),.op1((alu_src[1] ? reg_read2 : reg_read1)),.op2((alu_src[1] ? (alu_src[0] ? reg_read1 : shamt) : (alu_src[0] ? imm : reg_read2))),.zero(zero),.result(result));
	wire[31:0] mem_read;
	Mem #(7,32) dmem(.clock(clock.val),.wen(mem_write),.raddr1((result >> 2)),.rdata1(mem_read),.waddr((result >> 2)),.wdata(reg_read2));
	assign reg_write = (mem_to_reg ? mem_read : result);
	always @(posedge clock.val) begin
		if ((instr[5:0] == 6'd13)) begin
			begin
				$__put(STDOUT,"%_",reg_read1);
				$fflush(STDOUT);
			end 
			$finish(0);
		end 
		if ((instr == 32'h114b0001)) begin
			$yield();
		end 
		if (jump) begin
			pc <= jump_addr;
		end 
		else 
			if ((branch & zero)) begin
				pc <= branch_addr;
			end 
			else begin
				pc <= pc_4;
			end 
	end 
endmodule
*** DECL_OK @ 1517
*** PARSE @ 1517
(*non_volatile*) reg[31:0] imem[63:0];
*** ITEM_OK @ 1517
*** PARSE @ 1517
reg signed[31:0] s = $fopen("share/cascade/test/benchmark/mips32/run_bubble_128_1024.hex","r");
*** ITEM_OK @ 1517
*** PARSE @ 1517
reg signed[31:0] i = 0;
*** ITEM_OK @ 1517
*** PARSE @ 1517
reg[31:0] val = 0;
*** ITEM_OK @ 1517
*** PARSE @ 1517
initial begin
	for (i = 0; (i < 63); i = (i + 1)) begin
		$__get(s,"%u",val);
		imem[i] <= val;
	end 
end 
*** ITEM_OK @ 1517
*** PARSE @ 1517
wire[31:0] addr;
*** ITEM_OK @ 1517
*** PARSE @ 1517
wire[31:0] instr;
*** ITEM_OK @ 1517
*** PARSE @ 1517
assign instr = imem[addr];
*** ITEM_OK @ 1517
*** PARSE @ 1517
Mips32Yield mips32(.instr(instr),.raddr(addr));
*** ITEM_OK @ 1517
*** PARSE @ 3834070665
initial $retarget("regression/f1_minimal_tif");
*** ITEM_OK @ 3834070665
*** BEGIN @ 0
*** PARSE @ 0
(*__std = "logic",__loc = "local",__target = "sw"*) 
module Root();
	localparam STDIN = 32'h80000000;
	localparam STDOUT = 32'h80000001;
	localparam STDERR = 32'h80000002;
	localparam STDWARN = 32'h80000003;
	localparam STDINFO = 32'h80000004;
	localparam STDLOG = 32'h80000005;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "clock",__loc = "local",__target = "sw"*) 
module Clock(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "reset"*) 
module Reset(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "pad"*) 
module Pad(val);
	parameter WIDTH = 4;
	output wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "led"*) 
module Led(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "gpio"*) 
module Gpio(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__target = "sw;f1"*) 
Root root();
*** ITEM_OK @ 0
*** PARSE @ 0
Clock clock();
*** ITEM_OK @ 0
*** PARSE @ 0
module Alu(ctrl,op1,op2,zero,result);
	input wire[3:0] ctrl;
	input wire[31:0] op1;
	input wire[31:0] op2;
	output wire zero;
	output reg[31:0] result;
	always @* begin
		case (ctrl)
			4'b0000: result = (op1 << op2);
			4'b0001: result = (op1 >> op2);
			4'b0010: result = (op1 >>> op2);
			4'b0011: result = (op1 + op2);
			4'b0100: result = (op1 - op2);
			4'b0101: result = (op1 & op2);
			4'b0110: result = (op1 | op2);
			4'b0111: result = (op1 ^ op2);
			4'b1000: result = (!(op1 | op2));
			4'b1001: result = ((op1 < op2) ? 1 : 0);
			4'b1010: result = (op2 << 16);
			default: result = 0;
		endcase
	end 
	assign zero = (result == 32'b00000000000000000000000000000000);
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module AluControl(alu_op,op,ffield,ctrl);
	input wire alu_op;
	input wire[5:0] op;
	input wire[5:0] ffield;
	output reg[3:0] ctrl;
	always @* begin
		if ((alu_op == 0)) begin
			case (op)
				6'd4: ctrl = 4'b0100;
				6'd8: ctrl = 4'b0011;
				6'd10: ctrl = 4'b1001;
				6'd12: ctrl = 4'b0101;
				6'd13: ctrl = 4'b0110;
				6'd14: ctrl = 4'b0111;
				6'd15: ctrl = 4'b1010;
				6'd35: ctrl = 4'b0011;
				6'd43: ctrl = 4'b0011;
				default: ctrl = 0;
			endcase
		end 
		else begin
			case (ffield)
				6'd0: ctrl = 4'b0000;
				6'd2: ctrl = 4'b0001;
				6'd3: ctrl = 4'b0010;
				6'd6: ctrl = 4'b0001;
				6'd7: ctrl = 4'b0010;
				6'd32: ctrl = 4'b0011;
				6'd34: ctrl = 4'b0100;
				6'd36: ctrl = 4'b0101;
				6'd37: ctrl = 4'b0110;
				6'd38: ctrl = 4'b0111;
				6'd39: ctrl = 4'b1000;
				6'd42: ctrl = 4'b1001;
				default: ctrl = 0;
			endcase
		end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Control(instruction,reg_dst,jump,branch,mem_to_reg,alu_op,mem_write,alu_src,reg_write);
	input wire[31:0] instruction;
	output reg reg_dst;
	output reg jump;
	output reg branch;
	output reg mem_to_reg;
	output reg alu_op;
	output reg mem_write;
	output reg[1:0] alu_src;
	output reg reg_write;
	always @* begin
		case (instruction[31:26])
			6'd0: begin
				if ((instruction[5:0] == 6'd13)) begin
					reg_dst = 0;
					jump = 0;
					branch = 0;
					mem_to_reg = 0;
					alu_op = 0;
					mem_write = 0;
					alu_src = 2'b00;
					reg_write = 0;
				end 
				else 
					if ((instruction[5:0] < 6'd4)) begin
						reg_dst = 1;
						jump = 0;
						branch = 0;
						mem_to_reg = 0;
						alu_op = 1;
						mem_write = 0;
						alu_src = 2'b10;
						reg_write = 1;
					end 
					else 
						if ((instruction[5:0] < 6'd8)) begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b11;
							reg_write = 1;
						end 
						else begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b00;
							reg_write = 1;
						end 
			end 
			6'd2: begin
				reg_dst = 0;
				jump = 1;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd4: begin
				reg_dst = 0;
				jump = 0;
				branch = 1;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd8: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd10: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd12: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd13: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd14: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd15: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd35: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 1;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd43: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 1;
				alu_src = 2'b01;
				reg_write = 0;
			end 
			default: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
		endcase
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mem(clock,wen,raddr1,rdata1,raddr2,rdata2,waddr,wdata);
	parameter ADDR_SIZE = 4;
	parameter BYTE_SIZE = 8;
	input wire clock;
	input wire wen;
	input wire[(ADDR_SIZE - 1):0] raddr1;
	output wire[(BYTE_SIZE - 1):0] rdata1;
	input wire[(ADDR_SIZE - 1):0] raddr2;
	output wire[(BYTE_SIZE - 1):0] rdata2;
	input wire[(ADDR_SIZE - 1):0] waddr;
	input wire[(BYTE_SIZE - 1):0] wdata;
	reg[(BYTE_SIZE - 1):0] mem[((2 ** ADDR_SIZE) - 1):0];
	assign rdata1 = mem[raddr1];
	assign rdata2 = mem[raddr2];
	always @(posedge clock) if (wen) 
		mem[waddr] <= wdata;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mips32Yield(instr,raddr);
	input wire[31:0] instr;
	output wire[31:0] raddr;
	(*non_volatile*) reg[31:0] pc = 0;
	wire[31:0] pc_4;
	assign pc_4 = (pc + 4);
	assign raddr = (pc >> 2);
	wire reg_dst;
	wire jump;
	wire branch;
	wire mem_to_reg;
	wire alu_op;
	wire mem_write;
	wire[1:0] alu_src;
	wire c_reg_write;
	Control control(.instruction(instr),.reg_dst(reg_dst),.jump(jump),.branch(branch),.mem_to_reg(mem_to_reg),.alu_op(alu_op),.mem_write(mem_write),.alu_src(alu_src),.reg_write(c_reg_write));
	wire[4:0] shamt;
	assign shamt = instr[10:6];
	wire[31:0] imm;
	assign imm = {(instr[15] ? 16'b0000000000000001 : 16'b0000000000000000),instr[15:0]};
	wire[31:0] jump_addr;
	assign jump_addr = {pc_4[31:28],instr[25:0],2'b00};
	wire[31:0] branch_addr;
	assign branch_addr = (pc_4 + (imm << 2));
	wire[31:0] reg_read1;
	wire[31:0] reg_read2;
	wire[31:0] reg_write;
	Mem #(5,32) regs(.clock(clock.val),.wen(c_reg_write),.raddr1(instr[25:21]),.rdata1(reg_read1),.raddr2(instr[20:16]),.rdata2(reg_read2),.waddr((reg_dst ? instr[15:11] : instr[20:16])),.wdata(reg_write));
	wire[3:0] ctrl;
	AluControl alu_control(.alu_op(alu_op),.op(instr[31:26]),.ffield(instr[5:0]),.ctrl(ctrl));
	wire zero;
	wire[31:0] result;
	Alu alu(.ctrl(ctrl),.op1((alu_src[1] ? reg_read2 : reg_read1)),.op2((alu_src[1] ? (alu_src[0] ? reg_read1 : shamt) : (alu_src[0] ? imm : reg_read2))),.zero(zero),.result(result));
	wire[31:0] mem_read;
	Mem #(7,32) dmem(.clock(clock.val),.wen(mem_write),.raddr1((result >> 2)),.rdata1(mem_read),.waddr((result >> 2)),.wdata(reg_read2));
	assign reg_write = (mem_to_reg ? mem_read : result);
	always @(posedge clock.val) begin
		if ((instr[5:0] == 6'd13)) begin
			begin
				$__put(STDOUT,"%_",reg_read1);
				$fflush(STDOUT);
			end 
			$finish(0);
		end 
		if ((instr == 32'h114b0001)) begin
			$yield();
		end 
		if (jump) begin
			pc <= jump_addr;
		end 
		else 
			if ((branch & zero)) begin
				pc <= branch_addr;
			end 
			else begin
				pc <= pc_4;
			end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*non_volatile*) reg[31:0] imem[63:0];
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] s = $fopen("share/cascade/test/benchmark/mips32/run_bubble_128_1024.hex","r");
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] i = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
reg[31:0] val = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
initial begin
	for (i = 0; (i < 63); i = (i + 1)) begin
		$__get(s,"%u",val);
		imem[i] <= val;
	end 
end 
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] addr;
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] instr;
*** ITEM_OK @ 0
*** PARSE @ 0
assign instr = imem[addr];
*** ITEM_OK @ 0
*** PARSE @ 0
Mips32Yield mips32(.instr(instr),.raddr(addr));
*** ITEM_OK @ 0
*** PARSE @ 1762082972
initial $retarget("regression/f1_minimal_tif");
*** ITEM_OK @ 1762082972
*** BEGIN @ 0
*** PARSE @ 0
(*__std = "logic",__loc = "local",__target = "sw"*) 
module Root();
	localparam STDIN = 32'h80000000;
	localparam STDOUT = 32'h80000001;
	localparam STDERR = 32'h80000002;
	localparam STDWARN = 32'h80000003;
	localparam STDINFO = 32'h80000004;
	localparam STDLOG = 32'h80000005;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "clock",__loc = "local",__target = "sw"*) 
module Clock(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "reset"*) 
module Reset(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "pad"*) 
module Pad(val);
	parameter WIDTH = 4;
	output wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "led"*) 
module Led(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "gpio"*) 
module Gpio(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__target = "sw;f1;f1",__delay = 30,__state_safe_int*) 
Root root();
*** ITEM_OK @ 0
*** PARSE @ 0
Clock clock();
*** ITEM_OK @ 0
*** PARSE @ 0
module Alu(ctrl,op1,op2,zero,result);
	input wire[3:0] ctrl;
	input wire[31:0] op1;
	input wire[31:0] op2;
	output wire zero;
	output reg[31:0] result;
	always @* begin
		case (ctrl)
			4'b0000: result = (op1 << op2);
			4'b0001: result = (op1 >> op2);
			4'b0010: result = (op1 >>> op2);
			4'b0011: result = (op1 + op2);
			4'b0100: result = (op1 - op2);
			4'b0101: result = (op1 & op2);
			4'b0110: result = (op1 | op2);
			4'b0111: result = (op1 ^ op2);
			4'b1000: result = (!(op1 | op2));
			4'b1001: result = ((op1 < op2) ? 1 : 0);
			4'b1010: result = (op2 << 16);
			default: result = 0;
		endcase
	end 
	assign zero = (result == 32'b00000000000000000000000000000000);
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module AluControl(alu_op,op,ffield,ctrl);
	input wire alu_op;
	input wire[5:0] op;
	input wire[5:0] ffield;
	output reg[3:0] ctrl;
	always @* begin
		if ((alu_op == 0)) begin
			case (op)
				6'd4: ctrl = 4'b0100;
				6'd8: ctrl = 4'b0011;
				6'd10: ctrl = 4'b1001;
				6'd12: ctrl = 4'b0101;
				6'd13: ctrl = 4'b0110;
				6'd14: ctrl = 4'b0111;
				6'd15: ctrl = 4'b1010;
				6'd35: ctrl = 4'b0011;
				6'd43: ctrl = 4'b0011;
				default: ctrl = 0;
			endcase
		end 
		else begin
			case (ffield)
				6'd0: ctrl = 4'b0000;
				6'd2: ctrl = 4'b0001;
				6'd3: ctrl = 4'b0010;
				6'd6: ctrl = 4'b0001;
				6'd7: ctrl = 4'b0010;
				6'd32: ctrl = 4'b0011;
				6'd34: ctrl = 4'b0100;
				6'd36: ctrl = 4'b0101;
				6'd37: ctrl = 4'b0110;
				6'd38: ctrl = 4'b0111;
				6'd39: ctrl = 4'b1000;
				6'd42: ctrl = 4'b1001;
				default: ctrl = 0;
			endcase
		end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Control(instruction,reg_dst,jump,branch,mem_to_reg,alu_op,mem_write,alu_src,reg_write);
	input wire[31:0] instruction;
	output reg reg_dst;
	output reg jump;
	output reg branch;
	output reg mem_to_reg;
	output reg alu_op;
	output reg mem_write;
	output reg[1:0] alu_src;
	output reg reg_write;
	always @* begin
		case (instruction[31:26])
			6'd0: begin
				if ((instruction[5:0] == 6'd13)) begin
					reg_dst = 0;
					jump = 0;
					branch = 0;
					mem_to_reg = 0;
					alu_op = 0;
					mem_write = 0;
					alu_src = 2'b00;
					reg_write = 0;
				end 
				else 
					if ((instruction[5:0] < 6'd4)) begin
						reg_dst = 1;
						jump = 0;
						branch = 0;
						mem_to_reg = 0;
						alu_op = 1;
						mem_write = 0;
						alu_src = 2'b10;
						reg_write = 1;
					end 
					else 
						if ((instruction[5:0] < 6'd8)) begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b11;
							reg_write = 1;
						end 
						else begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b00;
							reg_write = 1;
						end 
			end 
			6'd2: begin
				reg_dst = 0;
				jump = 1;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd4: begin
				reg_dst = 0;
				jump = 0;
				branch = 1;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd8: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd10: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd12: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd13: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd14: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd15: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd35: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 1;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd43: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 1;
				alu_src = 2'b01;
				reg_write = 0;
			end 
			default: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
		endcase
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mem(clock,wen,raddr1,rdata1,raddr2,rdata2,waddr,wdata);
	parameter ADDR_SIZE = 4;
	parameter BYTE_SIZE = 8;
	input wire clock;
	input wire wen;
	input wire[(ADDR_SIZE - 1):0] raddr1;
	output wire[(BYTE_SIZE - 1):0] rdata1;
	input wire[(ADDR_SIZE - 1):0] raddr2;
	output wire[(BYTE_SIZE - 1):0] rdata2;
	input wire[(ADDR_SIZE - 1):0] waddr;
	input wire[(BYTE_SIZE - 1):0] wdata;
	reg[(BYTE_SIZE - 1):0] mem[((2 ** ADDR_SIZE) - 1):0];
	assign rdata1 = mem[raddr1];
	assign rdata2 = mem[raddr2];
	always @(posedge clock) if (wen) 
		mem[waddr] <= wdata;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mips32Yield(instr,raddr);
	input wire[31:0] instr;
	output wire[31:0] raddr;
	(*non_volatile*) reg[31:0] pc = 0;
	wire[31:0] pc_4;
	assign pc_4 = (pc + 4);
	assign raddr = (pc >> 2);
	wire reg_dst;
	wire jump;
	wire branch;
	wire mem_to_reg;
	wire alu_op;
	wire mem_write;
	wire[1:0] alu_src;
	wire c_reg_write;
	Control control(.instruction(instr),.reg_dst(reg_dst),.jump(jump),.branch(branch),.mem_to_reg(mem_to_reg),.alu_op(alu_op),.mem_write(mem_write),.alu_src(alu_src),.reg_write(c_reg_write));
	wire[4:0] shamt;
	assign shamt = instr[10:6];
	wire[31:0] imm;
	assign imm = {(instr[15] ? 16'b0000000000000001 : 16'b0000000000000000),instr[15:0]};
	wire[31:0] jump_addr;
	assign jump_addr = {pc_4[31:28],instr[25:0],2'b00};
	wire[31:0] branch_addr;
	assign branch_addr = (pc_4 + (imm << 2));
	wire[31:0] reg_read1;
	wire[31:0] reg_read2;
	wire[31:0] reg_write;
	Mem #(5,32) regs(.clock(clock.val),.wen(c_reg_write),.raddr1(instr[25:21]),.rdata1(reg_read1),.raddr2(instr[20:16]),.rdata2(reg_read2),.waddr((reg_dst ? instr[15:11] : instr[20:16])),.wdata(reg_write));
	wire[3:0] ctrl;
	AluControl alu_control(.alu_op(alu_op),.op(instr[31:26]),.ffield(instr[5:0]),.ctrl(ctrl));
	wire zero;
	wire[31:0] result;
	Alu alu(.ctrl(ctrl),.op1((alu_src[1] ? reg_read2 : reg_read1)),.op2((alu_src[1] ? (alu_src[0] ? reg_read1 : shamt) : (alu_src[0] ? imm : reg_read2))),.zero(zero),.result(result));
	wire[31:0] mem_read;
	Mem #(7,32) dmem(.clock(clock.val),.wen(mem_write),.raddr1((result >> 2)),.rdata1(mem_read),.waddr((result >> 2)),.wdata(reg_read2));
	assign reg_write = (mem_to_reg ? mem_read : result);
	always @(posedge clock.val) begin
		if ((instr[5:0] == 6'd13)) begin
			begin
				$__put(STDOUT,"%_",reg_read1);
				$fflush(STDOUT);
			end 
			$finish(0);
		end 
		if ((instr == 32'h114b0001)) begin
			$yield();
		end 
		if (jump) begin
			pc <= jump_addr;
		end 
		else 
			if ((branch & zero)) begin
				pc <= branch_addr;
			end 
			else begin
				pc <= pc_4;
			end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*non_volatile*) reg[31:0] imem[63:0];
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] s = $fopen("share/cascade/test/benchmark/mips32/run_bubble_128_1024.hex","r");
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] i = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
reg[31:0] val = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
initial begin
	for (i = 0; (i < 63); i = (i + 1)) begin
		$__get(s,"%u",val);
		imem[i] <= val;
	end 
end 
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] addr;
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] instr;
*** ITEM_OK @ 0
*** PARSE @ 0
assign instr = imem[addr];
*** ITEM_OK @ 0
*** PARSE @ 0
Mips32Yield mips32(.instr(instr),.raddr(addr));
*** ITEM_OK @ 0
*** BEGIN @ 0
*** PARSE @ 0
(*__std = "logic",__loc = "local",__target = "sw"*) 
module Root();
	localparam STDIN = 32'h80000000;
	localparam STDOUT = 32'h80000001;
	localparam STDERR = 32'h80000002;
	localparam STDWARN = 32'h80000003;
	localparam STDINFO = 32'h80000004;
	localparam STDLOG = 32'h80000005;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "clock",__loc = "local",__target = "sw"*) 
module Clock(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "reset"*) 
module Reset(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "pad"*) 
module Pad(val);
	parameter WIDTH = 4;
	output wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "led"*) 
module Led(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "gpio"*) 
module Gpio(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__target = "sw;verilator64"*) 
Root root();
*** ITEM_OK @ 0
*** PARSE @ 0
Clock clock();
*** ITEM_OK @ 0
*** PARSE @ 0
(*__loc = "/tmp/fpga_socket"*) 
Reset reset();
*** ITEM_OK @ 0
*** PARSE @ 0
(*__loc = "/tmp/fpga_socket"*) 
Pad #(4) pad();
*** ITEM_OK @ 0
*** PARSE @ 0
(*__loc = "/tmp/fpga_socket"*) 
Led #(8) led();
*** ITEM_OK @ 0
*** PARSE @ 0
module Alu(ctrl,op1,op2,zero,result);
	input wire[3:0] ctrl;
	input wire[31:0] op1;
	input wire[31:0] op2;
	output wire zero;
	output reg[31:0] result;
	always @* begin
		case (ctrl)
			4'b0000: result = (op1 << op2);
			4'b0001: result = (op1 >> op2);
			4'b0010: result = (op1 >>> op2);
			4'b0011: result = (op1 + op2);
			4'b0100: result = (op1 - op2);
			4'b0101: result = (op1 & op2);
			4'b0110: result = (op1 | op2);
			4'b0111: result = (op1 ^ op2);
			4'b1000: result = (!(op1 | op2));
			4'b1001: result = ((op1 < op2) ? 1 : 0);
			4'b1010: result = (op2 << 16);
			default: result = 0;
		endcase
	end 
	assign zero = (result == 32'b00000000000000000000000000000000);
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module AluControl(alu_op,op,ffield,ctrl);
	input wire alu_op;
	input wire[5:0] op;
	input wire[5:0] ffield;
	output reg[3:0] ctrl;
	always @* begin
		if ((alu_op == 0)) begin
			case (op)
				6'd4: ctrl = 4'b0100;
				6'd8: ctrl = 4'b0011;
				6'd10: ctrl = 4'b1001;
				6'd12: ctrl = 4'b0101;
				6'd13: ctrl = 4'b0110;
				6'd14: ctrl = 4'b0111;
				6'd15: ctrl = 4'b1010;
				6'd35: ctrl = 4'b0011;
				6'd43: ctrl = 4'b0011;
				default: ctrl = 0;
			endcase
		end 
		else begin
			case (ffield)
				6'd0: ctrl = 4'b0000;
				6'd2: ctrl = 4'b0001;
				6'd3: ctrl = 4'b0010;
				6'd6: ctrl = 4'b0001;
				6'd7: ctrl = 4'b0010;
				6'd32: ctrl = 4'b0011;
				6'd34: ctrl = 4'b0100;
				6'd36: ctrl = 4'b0101;
				6'd37: ctrl = 4'b0110;
				6'd38: ctrl = 4'b0111;
				6'd39: ctrl = 4'b1000;
				6'd42: ctrl = 4'b1001;
				default: ctrl = 0;
			endcase
		end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Control(instruction,reg_dst,jump,branch,mem_to_reg,alu_op,mem_write,alu_src,reg_write);
	input wire[31:0] instruction;
	output reg reg_dst;
	output reg jump;
	output reg branch;
	output reg mem_to_reg;
	output reg alu_op;
	output reg mem_write;
	output reg[1:0] alu_src;
	output reg reg_write;
	always @* begin
		case (instruction[31:26])
			6'd0: begin
				if ((instruction[5:0] == 6'd13)) begin
					reg_dst = 0;
					jump = 0;
					branch = 0;
					mem_to_reg = 0;
					alu_op = 0;
					mem_write = 0;
					alu_src = 2'b00;
					reg_write = 0;
				end 
				else 
					if ((instruction[5:0] < 6'd4)) begin
						reg_dst = 1;
						jump = 0;
						branch = 0;
						mem_to_reg = 0;
						alu_op = 1;
						mem_write = 0;
						alu_src = 2'b10;
						reg_write = 1;
					end 
					else 
						if ((instruction[5:0] < 6'd8)) begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b11;
							reg_write = 1;
						end 
						else begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b00;
							reg_write = 1;
						end 
			end 
			6'd2: begin
				reg_dst = 0;
				jump = 1;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd4: begin
				reg_dst = 0;
				jump = 0;
				branch = 1;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd8: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd10: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd12: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd13: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd14: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd15: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd35: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 1;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd43: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 1;
				alu_src = 2'b01;
				reg_write = 0;
			end 
			default: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
		endcase
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mem(clock,wen,raddr1,rdata1,raddr2,rdata2,waddr,wdata);
	parameter ADDR_SIZE = 4;
	parameter BYTE_SIZE = 8;
	input wire clock;
	input wire wen;
	input wire[(ADDR_SIZE - 1):0] raddr1;
	output wire[(BYTE_SIZE - 1):0] rdata1;
	input wire[(ADDR_SIZE - 1):0] raddr2;
	output wire[(BYTE_SIZE - 1):0] rdata2;
	input wire[(ADDR_SIZE - 1):0] waddr;
	input wire[(BYTE_SIZE - 1):0] wdata;
	reg[(BYTE_SIZE - 1):0] mem[((2 ** ADDR_SIZE) - 1):0];
	assign rdata1 = mem[raddr1];
	assign rdata2 = mem[raddr2];
	always @(posedge clock) if (wen) 
		mem[waddr] <= wdata;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mips32Yield(instr,raddr);
	input wire[31:0] instr;
	output wire[31:0] raddr;
	(*non_volatile*) reg[31:0] pc = 0;
	wire[31:0] pc_4;
	assign pc_4 = (pc + 4);
	assign raddr = (pc >> 2);
	wire reg_dst;
	wire jump;
	wire branch;
	wire mem_to_reg;
	wire alu_op;
	wire mem_write;
	wire[1:0] alu_src;
	wire c_reg_write;
	Control control(.instruction(instr),.reg_dst(reg_dst),.jump(jump),.branch(branch),.mem_to_reg(mem_to_reg),.alu_op(alu_op),.mem_write(mem_write),.alu_src(alu_src),.reg_write(c_reg_write));
	wire[4:0] shamt;
	assign shamt = instr[10:6];
	wire[31:0] imm;
	assign imm = {(instr[15] ? 16'b0000000000000001 : 16'b0000000000000000),instr[15:0]};
	wire[31:0] jump_addr;
	assign jump_addr = {pc_4[31:28],instr[25:0],2'b00};
	wire[31:0] branch_addr;
	assign branch_addr = (pc_4 + (imm << 2));
	wire[31:0] reg_read1;
	wire[31:0] reg_read2;
	wire[31:0] reg_write;
	Mem #(5,32) regs(.clock(clock.val),.wen(c_reg_write),.raddr1(instr[25:21]),.rdata1(reg_read1),.raddr2(instr[20:16]),.rdata2(reg_read2),.waddr((reg_dst ? instr[15:11] : instr[20:16])),.wdata(reg_write));
	wire[3:0] ctrl;
	AluControl alu_control(.alu_op(alu_op),.op(instr[31:26]),.ffield(instr[5:0]),.ctrl(ctrl));
	wire zero;
	wire[31:0] result;
	Alu alu(.ctrl(ctrl),.op1((alu_src[1] ? reg_read2 : reg_read1)),.op2((alu_src[1] ? (alu_src[0] ? reg_read1 : shamt) : (alu_src[0] ? imm : reg_read2))),.zero(zero),.result(result));
	wire[31:0] mem_read;
	Mem #(7,32) dmem(.clock(clock.val),.wen(mem_write),.raddr1((result >> 2)),.rdata1(mem_read),.waddr((result >> 2)),.wdata(reg_read2));
	assign reg_write = (mem_to_reg ? mem_read : result);
	always @(posedge clock.val) begin
		if ((instr[5:0] == 6'd13)) begin
			begin
				$__put(STDOUT,"%_",reg_read1);
				$fflush(STDOUT);
			end 
			$finish(0);
		end 
		if ((instr == 32'h114b0001)) begin
			$yield();
		end 
		if (jump) begin
			pc <= jump_addr;
		end 
		else 
			if ((branch & zero)) begin
				pc <= branch_addr;
			end 
			else begin
				pc <= pc_4;
			end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*non_volatile*) reg[31:0] imem[63:0];
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] s = $fopen("share/cascade/test/benchmark/mips32/run_bubble_128_1024.hex","r");
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] i = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
reg[31:0] val = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
initial begin
	for (i = 0; (i < 63); i = (i + 1)) begin
		$__get(s,"%u",val);
		imem[i] <= val;
	end 
end 
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] addr;
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] instr;
*** ITEM_OK @ 0
*** PARSE @ 0
assign instr = imem[addr];
*** ITEM_OK @ 0
*** PARSE @ 0
Mips32Yield mips32(.instr(instr),.raddr(addr));
*** ITEM_OK @ 0
*** BEGIN @ 0
*** PARSE @ 0
(*__std = "logic",__loc = "local",__target = "sw"*) 
module Root();
	localparam STDIN = 32'h80000000;
	localparam STDOUT = 32'h80000001;
	localparam STDERR = 32'h80000002;
	localparam STDWARN = 32'h80000003;
	localparam STDINFO = 32'h80000004;
	localparam STDLOG = 32'h80000005;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "clock",__loc = "local",__target = "sw"*) 
module Clock(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "reset"*) 
module Reset(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "pad"*) 
module Pad(val);
	parameter WIDTH = 4;
	output wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "led"*) 
module Led(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "gpio"*) 
module Gpio(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__target = "sw;f1;f1",__delay = 30,__state_safe_int*) 
Root root();
*** ITEM_OK @ 0
*** PARSE @ 0
Clock clock();
*** ITEM_OK @ 0
*** PARSE @ 0
module Alu(ctrl,op1,op2,zero,result);
	input wire[3:0] ctrl;
	input wire[31:0] op1;
	input wire[31:0] op2;
	output wire zero;
	output reg[31:0] result;
	always @* begin
		case (ctrl)
			4'b0000: result = (op1 << op2);
			4'b0001: result = (op1 >> op2);
			4'b0010: result = (op1 >>> op2);
			4'b0011: result = (op1 + op2);
			4'b0100: result = (op1 - op2);
			4'b0101: result = (op1 & op2);
			4'b0110: result = (op1 | op2);
			4'b0111: result = (op1 ^ op2);
			4'b1000: result = (!(op1 | op2));
			4'b1001: result = ((op1 < op2) ? 1 : 0);
			4'b1010: result = (op2 << 16);
			default: result = 0;
		endcase
	end 
	assign zero = (result == 32'b00000000000000000000000000000000);
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module AluControl(alu_op,op,ffield,ctrl);
	input wire alu_op;
	input wire[5:0] op;
	input wire[5:0] ffield;
	output reg[3:0] ctrl;
	always @* begin
		if ((alu_op == 0)) begin
			case (op)
				6'd4: ctrl = 4'b0100;
				6'd8: ctrl = 4'b0011;
				6'd10: ctrl = 4'b1001;
				6'd12: ctrl = 4'b0101;
				6'd13: ctrl = 4'b0110;
				6'd14: ctrl = 4'b0111;
				6'd15: ctrl = 4'b1010;
				6'd35: ctrl = 4'b0011;
				6'd43: ctrl = 4'b0011;
				default: ctrl = 0;
			endcase
		end 
		else begin
			case (ffield)
				6'd0: ctrl = 4'b0000;
				6'd2: ctrl = 4'b0001;
				6'd3: ctrl = 4'b0010;
				6'd6: ctrl = 4'b0001;
				6'd7: ctrl = 4'b0010;
				6'd32: ctrl = 4'b0011;
				6'd34: ctrl = 4'b0100;
				6'd36: ctrl = 4'b0101;
				6'd37: ctrl = 4'b0110;
				6'd38: ctrl = 4'b0111;
				6'd39: ctrl = 4'b1000;
				6'd42: ctrl = 4'b1001;
				default: ctrl = 0;
			endcase
		end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Control(instruction,reg_dst,jump,branch,mem_to_reg,alu_op,mem_write,alu_src,reg_write);
	input wire[31:0] instruction;
	output reg reg_dst;
	output reg jump;
	output reg branch;
	output reg mem_to_reg;
	output reg alu_op;
	output reg mem_write;
	output reg[1:0] alu_src;
	output reg reg_write;
	always @* begin
		case (instruction[31:26])
			6'd0: begin
				if ((instruction[5:0] == 6'd13)) begin
					reg_dst = 0;
					jump = 0;
					branch = 0;
					mem_to_reg = 0;
					alu_op = 0;
					mem_write = 0;
					alu_src = 2'b00;
					reg_write = 0;
				end 
				else 
					if ((instruction[5:0] < 6'd4)) begin
						reg_dst = 1;
						jump = 0;
						branch = 0;
						mem_to_reg = 0;
						alu_op = 1;
						mem_write = 0;
						alu_src = 2'b10;
						reg_write = 1;
					end 
					else 
						if ((instruction[5:0] < 6'd8)) begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b11;
							reg_write = 1;
						end 
						else begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b00;
							reg_write = 1;
						end 
			end 
			6'd2: begin
				reg_dst = 0;
				jump = 1;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd4: begin
				reg_dst = 0;
				jump = 0;
				branch = 1;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd8: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd10: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd12: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd13: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd14: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd15: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd35: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 1;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd43: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 1;
				alu_src = 2'b01;
				reg_write = 0;
			end 
			default: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
		endcase
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mem(clock,wen,raddr1,rdata1,raddr2,rdata2,waddr,wdata);
	parameter ADDR_SIZE = 4;
	parameter BYTE_SIZE = 8;
	input wire clock;
	input wire wen;
	input wire[(ADDR_SIZE - 1):0] raddr1;
	output wire[(BYTE_SIZE - 1):0] rdata1;
	input wire[(ADDR_SIZE - 1):0] raddr2;
	output wire[(BYTE_SIZE - 1):0] rdata2;
	input wire[(ADDR_SIZE - 1):0] waddr;
	input wire[(BYTE_SIZE - 1):0] wdata;
	reg[(BYTE_SIZE - 1):0] mem[((2 ** ADDR_SIZE) - 1):0];
	assign rdata1 = mem[raddr1];
	assign rdata2 = mem[raddr2];
	always @(posedge clock) if (wen) 
		mem[waddr] <= wdata;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mips32(instr,raddr);
	input wire[31:0] instr;
	output wire[31:0] raddr;
	reg[31:0] pc = 0;
	wire[31:0] pc_4;
	assign pc_4 = (pc + 4);
	assign raddr = (pc >> 2);
	wire reg_dst;
	wire jump;
	wire branch;
	wire mem_to_reg;
	wire alu_op;
	wire mem_write;
	wire[1:0] alu_src;
	wire c_reg_write;
	Control control(.instruction(instr),.reg_dst(reg_dst),.jump(jump),.branch(branch),.mem_to_reg(mem_to_reg),.alu_op(alu_op),.mem_write(mem_write),.alu_src(alu_src),.reg_write(c_reg_write));
	wire[4:0] shamt;
	assign shamt = instr[10:6];
	wire[31:0] imm;
	assign imm = {(instr[15] ? 16'b0000000000000001 : 16'b0000000000000000),instr[15:0]};
	wire[31:0] jump_addr;
	assign jump_addr = {pc_4[31:28],instr[25:0],2'b00};
	wire[31:0] branch_addr;
	assign branch_addr = (pc_4 + (imm << 2));
	wire[31:0] reg_read1;
	wire[31:0] reg_read2;
	wire[31:0] reg_write;
	Mem #(5,32) regs(.clock(clock.val),.wen(c_reg_write),.raddr1(instr[25:21]),.rdata1(reg_read1),.raddr2(instr[20:16]),.rdata2(reg_read2),.waddr((reg_dst ? instr[15:11] : instr[20:16])),.wdata(reg_write));
	wire[3:0] ctrl;
	AluControl alu_control(.alu_op(alu_op),.op(instr[31:26]),.ffield(instr[5:0]),.ctrl(ctrl));
	wire zero;
	wire[31:0] result;
	Alu alu(.ctrl(ctrl),.op1((alu_src[1] ? reg_read2 : reg_read1)),.op2((alu_src[1] ? (alu_src[0] ? reg_read1 : shamt) : (alu_src[0] ? imm : reg_read2))),.zero(zero),.result(result));
	wire[31:0] mem_read;
	Mem #(7,32) dmem(.clock(clock.val),.wen(mem_write),.raddr1((result >> 2)),.rdata1(mem_read),.waddr((result >> 2)),.wdata(reg_read2));
	assign reg_write = (mem_to_reg ? mem_read : result);
	always @(posedge clock.val) begin
		if ((instr[5:0] == 6'd13)) begin
			begin
				$__put(STDOUT,"%_",reg_read1);
				$fflush(STDOUT);
			end 
			$finish(0);
		end 
		if (jump) begin
			pc <= jump_addr;
		end 
		else 
			if ((branch & zero)) begin
				pc <= branch_addr;
			end 
			else begin
				pc <= pc_4;
			end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
reg[31:0] imem[63:0];
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] s = $fopen("share/cascade/test/benchmark/mips32/run_bubble_128_1024.hex","r");
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] i = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
reg[31:0] val = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
initial begin
	for (i = 0; (i < 63); i = (i + 1)) begin
		$__get(s,"%u",val);
		imem[i] <= val;
	end 
end 
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] addr;
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] instr;
*** ITEM_OK @ 0
*** PARSE @ 0
assign instr = imem[addr];
*** ITEM_OK @ 0
*** PARSE @ 0
Mips32 mips32(.instr(instr),.raddr(addr));
*** ITEM_OK @ 0
*** END @ 486520810
*** BEGIN @ 0
*** PARSE @ 0
(*__std = "logic",__loc = "local",__target = "sw"*) 
module Root();
	localparam STDIN = 32'h80000000;
	localparam STDOUT = 32'h80000001;
	localparam STDERR = 32'h80000002;
	localparam STDWARN = 32'h80000003;
	localparam STDINFO = 32'h80000004;
	localparam STDLOG = 32'h80000005;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "clock",__loc = "local",__target = "sw"*) 
module Clock(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "reset"*) 
module Reset(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "pad"*) 
module Pad(val);
	parameter WIDTH = 4;
	output wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "led"*) 
module Led(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "gpio"*) 
module Gpio(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__target = "sw;verilator64"*) 
Root root();
*** ITEM_OK @ 0
*** PARSE @ 0
Clock clock();
*** ITEM_OK @ 0
*** PARSE @ 0
(*__loc = "/tmp/fpga_socket"*) 
Reset reset();
*** ITEM_OK @ 0
*** PARSE @ 0
(*__loc = "/tmp/fpga_socket"*) 
Pad #(4) pad();
*** ITEM_OK @ 0
*** PARSE @ 0
(*__loc = "/tmp/fpga_socket"*) 
Led #(8) led();
*** ITEM_OK @ 0
*** PARSE @ 0
module Alu(ctrl,op1,op2,zero,result);
	input wire[3:0] ctrl;
	input wire[31:0] op1;
	input wire[31:0] op2;
	output wire zero;
	output reg[31:0] result;
	always @* begin
		case (ctrl)
			4'b0000: result = (op1 << op2);
			4'b0001: result = (op1 >> op2);
			4'b0010: result = (op1 >>> op2);
			4'b0011: result = (op1 + op2);
			4'b0100: result = (op1 - op2);
			4'b0101: result = (op1 & op2);
			4'b0110: result = (op1 | op2);
			4'b0111: result = (op1 ^ op2);
			4'b1000: result = (!(op1 | op2));
			4'b1001: result = ((op1 < op2) ? 1 : 0);
			4'b1010: result = (op2 << 16);
			default: result = 0;
		endcase
	end 
	assign zero = (result == 32'b00000000000000000000000000000000);
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module AluControl(alu_op,op,ffield,ctrl);
	input wire alu_op;
	input wire[5:0] op;
	input wire[5:0] ffield;
	output reg[3:0] ctrl;
	always @* begin
		if ((alu_op == 0)) begin
			case (op)
				6'd4: ctrl = 4'b0100;
				6'd8: ctrl = 4'b0011;
				6'd10: ctrl = 4'b1001;
				6'd12: ctrl = 4'b0101;
				6'd13: ctrl = 4'b0110;
				6'd14: ctrl = 4'b0111;
				6'd15: ctrl = 4'b1010;
				6'd35: ctrl = 4'b0011;
				6'd43: ctrl = 4'b0011;
				default: ctrl = 0;
			endcase
		end 
		else begin
			case (ffield)
				6'd0: ctrl = 4'b0000;
				6'd2: ctrl = 4'b0001;
				6'd3: ctrl = 4'b0010;
				6'd6: ctrl = 4'b0001;
				6'd7: ctrl = 4'b0010;
				6'd32: ctrl = 4'b0011;
				6'd34: ctrl = 4'b0100;
				6'd36: ctrl = 4'b0101;
				6'd37: ctrl = 4'b0110;
				6'd38: ctrl = 4'b0111;
				6'd39: ctrl = 4'b1000;
				6'd42: ctrl = 4'b1001;
				default: ctrl = 0;
			endcase
		end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Control(instruction,reg_dst,jump,branch,mem_to_reg,alu_op,mem_write,alu_src,reg_write);
	input wire[31:0] instruction;
	output reg reg_dst;
	output reg jump;
	output reg branch;
	output reg mem_to_reg;
	output reg alu_op;
	output reg mem_write;
	output reg[1:0] alu_src;
	output reg reg_write;
	always @* begin
		case (instruction[31:26])
			6'd0: begin
				if ((instruction[5:0] == 6'd13)) begin
					reg_dst = 0;
					jump = 0;
					branch = 0;
					mem_to_reg = 0;
					alu_op = 0;
					mem_write = 0;
					alu_src = 2'b00;
					reg_write = 0;
				end 
				else 
					if ((instruction[5:0] < 6'd4)) begin
						reg_dst = 1;
						jump = 0;
						branch = 0;
						mem_to_reg = 0;
						alu_op = 1;
						mem_write = 0;
						alu_src = 2'b10;
						reg_write = 1;
					end 
					else 
						if ((instruction[5:0] < 6'd8)) begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b11;
							reg_write = 1;
						end 
						else begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b00;
							reg_write = 1;
						end 
			end 
			6'd2: begin
				reg_dst = 0;
				jump = 1;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd4: begin
				reg_dst = 0;
				jump = 0;
				branch = 1;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd8: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd10: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd12: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd13: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd14: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd15: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd35: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 1;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd43: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 1;
				alu_src = 2'b01;
				reg_write = 0;
			end 
			default: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
		endcase
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mem(clock,wen,raddr1,rdata1,raddr2,rdata2,waddr,wdata);
	parameter ADDR_SIZE = 4;
	parameter BYTE_SIZE = 8;
	input wire clock;
	input wire wen;
	input wire[(ADDR_SIZE - 1):0] raddr1;
	output wire[(BYTE_SIZE - 1):0] rdata1;
	input wire[(ADDR_SIZE - 1):0] raddr2;
	output wire[(BYTE_SIZE - 1):0] rdata2;
	input wire[(ADDR_SIZE - 1):0] waddr;
	input wire[(BYTE_SIZE - 1):0] wdata;
	reg[(BYTE_SIZE - 1):0] mem[((2 ** ADDR_SIZE) - 1):0];
	assign rdata1 = mem[raddr1];
	assign rdata2 = mem[raddr2];
	always @(posedge clock) if (wen) 
		mem[waddr] <= wdata;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mips32(instr,raddr);
	input wire[31:0] instr;
	output wire[31:0] raddr;
	reg[31:0] pc = 0;
	wire[31:0] pc_4;
	assign pc_4 = (pc + 4);
	assign raddr = (pc >> 2);
	wire reg_dst;
	wire jump;
	wire branch;
	wire mem_to_reg;
	wire alu_op;
	wire mem_write;
	wire[1:0] alu_src;
	wire c_reg_write;
	Control control(.instruction(instr),.reg_dst(reg_dst),.jump(jump),.branch(branch),.mem_to_reg(mem_to_reg),.alu_op(alu_op),.mem_write(mem_write),.alu_src(alu_src),.reg_write(c_reg_write));
	wire[4:0] shamt;
	assign shamt = instr[10:6];
	wire[31:0] imm;
	assign imm = {(instr[15] ? 16'b0000000000000001 : 16'b0000000000000000),instr[15:0]};
	wire[31:0] jump_addr;
	assign jump_addr = {pc_4[31:28],instr[25:0],2'b00};
	wire[31:0] branch_addr;
	assign branch_addr = (pc_4 + (imm << 2));
	wire[31:0] reg_read1;
	wire[31:0] reg_read2;
	wire[31:0] reg_write;
	Mem #(5,32) regs(.clock(clock.val),.wen(c_reg_write),.raddr1(instr[25:21]),.rdata1(reg_read1),.raddr2(instr[20:16]),.rdata2(reg_read2),.waddr((reg_dst ? instr[15:11] : instr[20:16])),.wdata(reg_write));
	wire[3:0] ctrl;
	AluControl alu_control(.alu_op(alu_op),.op(instr[31:26]),.ffield(instr[5:0]),.ctrl(ctrl));
	wire zero;
	wire[31:0] result;
	Alu alu(.ctrl(ctrl),.op1((alu_src[1] ? reg_read2 : reg_read1)),.op2((alu_src[1] ? (alu_src[0] ? reg_read1 : shamt) : (alu_src[0] ? imm : reg_read2))),.zero(zero),.result(result));
	wire[31:0] mem_read;
	Mem #(7,32) dmem(.clock(clock.val),.wen(mem_write),.raddr1((result >> 2)),.rdata1(mem_read),.waddr((result >> 2)),.wdata(reg_read2));
	assign reg_write = (mem_to_reg ? mem_read : result);
	always @(posedge clock.val) begin
		if ((instr[5:0] == 6'd13)) begin
			begin
				$__put(STDOUT,"%_",reg_read1);
				$fflush(STDOUT);
			end 
			$finish(0);
		end 
		if (jump) begin
			pc <= jump_addr;
		end 
		else 
			if ((branch & zero)) begin
				pc <= branch_addr;
			end 
			else begin
				pc <= pc_4;
			end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
reg[31:0] imem[63:0];
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] s = $fopen("share/cascade/test/benchmark/mips32/run_bubble_128_1024.hex","r");
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] i = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
reg[31:0] val = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
initial begin
	for (i = 0; (i < 63); i = (i + 1)) begin
		$__get(s,"%u",val);
		imem[i] <= val;
	end 
end 
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] addr;
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] instr;
*** ITEM_OK @ 0
*** PARSE @ 0
assign instr = imem[addr];
*** ITEM_OK @ 0
*** PARSE @ 0
Mips32 mips32(.instr(instr),.raddr(addr));
*** ITEM_OK @ 0
*** BEGIN @ 0
*** BEGIN @ 0
*** PARSE @ 0
(*__std = "logic",__loc = "local",__target = "sw"*) 
module Root();
	localparam STDIN = 32'h80000000;
	localparam STDOUT = 32'h80000001;
	localparam STDERR = 32'h80000002;
	localparam STDWARN = 32'h80000003;
	localparam STDINFO = 32'h80000004;
	localparam STDLOG = 32'h80000005;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "clock",__loc = "local",__target = "sw"*) 
module Clock(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "reset"*) 
module Reset(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "pad"*) 
module Pad(val);
	parameter WIDTH = 4;
	output wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "led"*) 
module Led(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "gpio"*) 
module Gpio(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__target = "sw;sw",__delay = 10*) 
Root root();
*** ITEM_OK @ 0
*** PARSE @ 0
Clock clock();
*** ITEM_OK @ 0
*** PARSE @ 0
module Alu(ctrl,op1,op2,zero,result);
	input wire[3:0] ctrl;
	input wire[31:0] op1;
	input wire[31:0] op2;
	output wire zero;
	output reg[31:0] result;
	always @* begin
		case (ctrl)
			4'b0000: result = (op1 << op2);
			4'b0001: result = (op1 >> op2);
			4'b0010: result = (op1 >>> op2);
			4'b0011: result = (op1 + op2);
			4'b0100: result = (op1 - op2);
			4'b0101: result = (op1 & op2);
			4'b0110: result = (op1 | op2);
			4'b0111: result = (op1 ^ op2);
			4'b1000: result = (!(op1 | op2));
			4'b1001: result = ((op1 < op2) ? 1 : 0);
			4'b1010: result = (op2 << 16);
			default: result = 0;
		endcase
	end 
	assign zero = (result == 32'b00000000000000000000000000000000);
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module AluControl(alu_op,op,ffield,ctrl);
	input wire alu_op;
	input wire[5:0] op;
	input wire[5:0] ffield;
	output reg[3:0] ctrl;
	always @* begin
		if ((alu_op == 0)) begin
			case (op)
				6'd4: ctrl = 4'b0100;
				6'd8: ctrl = 4'b0011;
				6'd10: ctrl = 4'b1001;
				6'd12: ctrl = 4'b0101;
				6'd13: ctrl = 4'b0110;
				6'd14: ctrl = 4'b0111;
				6'd15: ctrl = 4'b1010;
				6'd35: ctrl = 4'b0011;
				6'd43: ctrl = 4'b0011;
				default: ctrl = 0;
			endcase
		end 
		else begin
			case (ffield)
				6'd0: ctrl = 4'b0000;
				6'd2: ctrl = 4'b0001;
				6'd3: ctrl = 4'b0010;
				6'd6: ctrl = 4'b0001;
				6'd7: ctrl = 4'b0010;
				6'd32: ctrl = 4'b0011;
				6'd34: ctrl = 4'b0100;
				6'd36: ctrl = 4'b0101;
				6'd37: ctrl = 4'b0110;
				6'd38: ctrl = 4'b0111;
				6'd39: ctrl = 4'b1000;
				6'd42: ctrl = 4'b1001;
				default: ctrl = 0;
			endcase
		end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Control(instruction,reg_dst,jump,branch,mem_to_reg,alu_op,mem_write,alu_src,reg_write);
	input wire[31:0] instruction;
	output reg reg_dst;
	output reg jump;
	output reg branch;
	output reg mem_to_reg;
	output reg alu_op;
	output reg mem_write;
	output reg[1:0] alu_src;
	output reg reg_write;
	always @* begin
		case (instruction[31:26])
			6'd0: begin
				if ((instruction[5:0] == 6'd13)) begin
					reg_dst = 0;
					jump = 0;
					branch = 0;
					mem_to_reg = 0;
					alu_op = 0;
					mem_write = 0;
					alu_src = 2'b00;
					reg_write = 0;
				end 
				else 
					if ((instruction[5:0] < 6'd4)) begin
						reg_dst = 1;
						jump = 0;
						branch = 0;
						mem_to_reg = 0;
						alu_op = 1;
						mem_write = 0;
						alu_src = 2'b10;
						reg_write = 1;
					end 
					else 
						if ((instruction[5:0] < 6'd8)) begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b11;
							reg_write = 1;
						end 
						else begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b00;
							reg_write = 1;
						end 
			end 
			6'd2: begin
				reg_dst = 0;
				jump = 1;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd4: begin
				reg_dst = 0;
				jump = 0;
				branch = 1;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd8: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd10: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd12: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd13: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd14: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd15: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd35: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 1;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd43: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 1;
				alu_src = 2'b01;
				reg_write = 0;
			end 
			default: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
		endcase
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mem(clock,wen,raddr1,rdata1,raddr2,rdata2,waddr,wdata);
	parameter ADDR_SIZE = 4;
	parameter BYTE_SIZE = 8;
	input wire clock;
	input wire wen;
	input wire[(ADDR_SIZE - 1):0] raddr1;
	output wire[(BYTE_SIZE - 1):0] rdata1;
	input wire[(ADDR_SIZE - 1):0] raddr2;
	output wire[(BYTE_SIZE - 1):0] rdata2;
	input wire[(ADDR_SIZE - 1):0] waddr;
	input wire[(BYTE_SIZE - 1):0] wdata;
	reg[(BYTE_SIZE - 1):0] mem[((2 ** ADDR_SIZE) - 1):0];
	assign rdata1 = mem[raddr1];
	assign rdata2 = mem[raddr2];
	always @(posedge clock) if (wen) 
		mem[waddr] <= wdata;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mips32Yield(instr,raddr);
	input wire[31:0] instr;
	output wire[31:0] raddr;
	(*non_volatile*) reg[31:0] pc = 0;
	wire[31:0] pc_4;
	assign pc_4 = (pc + 4);
	assign raddr = (pc >> 2);
	wire reg_dst;
	wire jump;
	wire branch;
	wire mem_to_reg;
	wire alu_op;
	wire mem_write;
	wire[1:0] alu_src;
	wire c_reg_write;
	Control control(.instruction(instr),.reg_dst(reg_dst),.jump(jump),.branch(branch),.mem_to_reg(mem_to_reg),.alu_op(alu_op),.mem_write(mem_write),.alu_src(alu_src),.reg_write(c_reg_write));
	wire[4:0] shamt;
	assign shamt = instr[10:6];
	wire[31:0] imm;
	assign imm = {(instr[15] ? 16'b0000000000000001 : 16'b0000000000000000),instr[15:0]};
	wire[31:0] jump_addr;
	assign jump_addr = {pc_4[31:28],instr[25:0],2'b00};
	wire[31:0] branch_addr;
	assign branch_addr = (pc_4 + (imm << 2));
	wire[31:0] reg_read1;
	wire[31:0] reg_read2;
	wire[31:0] reg_write;
	Mem #(5,32) regs(.clock(clock.val),.wen(c_reg_write),.raddr1(instr[25:21]),.rdata1(reg_read1),.raddr2(instr[20:16]),.rdata2(reg_read2),.waddr((reg_dst ? instr[15:11] : instr[20:16])),.wdata(reg_write));
	wire[3:0] ctrl;
	AluControl alu_control(.alu_op(alu_op),.op(instr[31:26]),.ffield(instr[5:0]),.ctrl(ctrl));
	wire zero;
	wire[31:0] result;
	Alu alu(.ctrl(ctrl),.op1((alu_src[1] ? reg_read2 : reg_read1)),.op2((alu_src[1] ? (alu_src[0] ? reg_read1 : shamt) : (alu_src[0] ? imm : reg_read2))),.zero(zero),.result(result));
	wire[31:0] mem_read;
	Mem #(7,32) dmem(.clock(clock.val),.wen(mem_write),.raddr1((result >> 2)),.rdata1(mem_read),.waddr((result >> 2)),.wdata(reg_read2));
	assign reg_write = (mem_to_reg ? mem_read : result);
	always @(posedge clock.val) begin
		if ((instr[5:0] == 6'd13)) begin
			begin
				$__put(STDOUT,"%_",reg_read1);
				$fflush(STDOUT);
			end 
			$finish(0);
		end 
		if ((instr == 32'h114b0001)) begin
			$yield();
		end 
		if (jump) begin
			pc <= jump_addr;
		end 
		else 
			if ((branch & zero)) begin
				pc <= branch_addr;
			end 
			else begin
				pc <= pc_4;
			end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*non_volatile*) reg[31:0] imem[63:0];
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] s = $fopen("share/cascade/test/benchmark/mips32/run_bubble_128_1024.hex","r");
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] i = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
reg[31:0] val = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
initial begin
	for (i = 0; (i < 63); i = (i + 1)) begin
		$__get(s,"%u",val);
		imem[i] <= val;
	end 
end 
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] addr;
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] instr;
*** ITEM_OK @ 0
*** PARSE @ 0
assign instr = imem[addr];
*** ITEM_OK @ 0
*** PARSE @ 0
Mips32Yield mips32(.instr(instr),.raddr(addr));
*** ITEM_OK @ 0
*** BEGIN @ 0
*** PARSE @ 0
(*__std = "logic",__loc = "local",__target = "sw"*) 
module Root();
	localparam STDIN = 32'h80000000;
	localparam STDOUT = 32'h80000001;
	localparam STDERR = 32'h80000002;
	localparam STDWARN = 32'h80000003;
	localparam STDINFO = 32'h80000004;
	localparam STDLOG = 32'h80000005;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "clock",__loc = "local",__target = "sw"*) 
module Clock(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "reset"*) 
module Reset(val);
	output wire val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "pad"*) 
module Pad(val);
	parameter WIDTH = 4;
	output wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "led"*) 
module Led(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__std = "gpio"*) 
module Gpio(val);
	parameter WIDTH = 8;
	input wire[(WIDTH - 1):0] val;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*__target = "sw;f1;f1",__delay = 30,__state_safe_int*) 
Root root();
*** ITEM_OK @ 0
*** PARSE @ 0
Clock clock();
*** ITEM_OK @ 0
*** PARSE @ 0
module Alu(ctrl,op1,op2,zero,result);
	input wire[3:0] ctrl;
	input wire[31:0] op1;
	input wire[31:0] op2;
	output wire zero;
	output reg[31:0] result;
	always @* begin
		case (ctrl)
			4'b0000: result = (op1 << op2);
			4'b0001: result = (op1 >> op2);
			4'b0010: result = (op1 >>> op2);
			4'b0011: result = (op1 + op2);
			4'b0100: result = (op1 - op2);
			4'b0101: result = (op1 & op2);
			4'b0110: result = (op1 | op2);
			4'b0111: result = (op1 ^ op2);
			4'b1000: result = (!(op1 | op2));
			4'b1001: result = ((op1 < op2) ? 1 : 0);
			4'b1010: result = (op2 << 16);
			default: result = 0;
		endcase
	end 
	assign zero = (result == 32'b00000000000000000000000000000000);
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module AluControl(alu_op,op,ffield,ctrl);
	input wire alu_op;
	input wire[5:0] op;
	input wire[5:0] ffield;
	output reg[3:0] ctrl;
	always @* begin
		if ((alu_op == 0)) begin
			case (op)
				6'd4: ctrl = 4'b0100;
				6'd8: ctrl = 4'b0011;
				6'd10: ctrl = 4'b1001;
				6'd12: ctrl = 4'b0101;
				6'd13: ctrl = 4'b0110;
				6'd14: ctrl = 4'b0111;
				6'd15: ctrl = 4'b1010;
				6'd35: ctrl = 4'b0011;
				6'd43: ctrl = 4'b0011;
				default: ctrl = 0;
			endcase
		end 
		else begin
			case (ffield)
				6'd0: ctrl = 4'b0000;
				6'd2: ctrl = 4'b0001;
				6'd3: ctrl = 4'b0010;
				6'd6: ctrl = 4'b0001;
				6'd7: ctrl = 4'b0010;
				6'd32: ctrl = 4'b0011;
				6'd34: ctrl = 4'b0100;
				6'd36: ctrl = 4'b0101;
				6'd37: ctrl = 4'b0110;
				6'd38: ctrl = 4'b0111;
				6'd39: ctrl = 4'b1000;
				6'd42: ctrl = 4'b1001;
				default: ctrl = 0;
			endcase
		end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Control(instruction,reg_dst,jump,branch,mem_to_reg,alu_op,mem_write,alu_src,reg_write);
	input wire[31:0] instruction;
	output reg reg_dst;
	output reg jump;
	output reg branch;
	output reg mem_to_reg;
	output reg alu_op;
	output reg mem_write;
	output reg[1:0] alu_src;
	output reg reg_write;
	always @* begin
		case (instruction[31:26])
			6'd0: begin
				if ((instruction[5:0] == 6'd13)) begin
					reg_dst = 0;
					jump = 0;
					branch = 0;
					mem_to_reg = 0;
					alu_op = 0;
					mem_write = 0;
					alu_src = 2'b00;
					reg_write = 0;
				end 
				else 
					if ((instruction[5:0] < 6'd4)) begin
						reg_dst = 1;
						jump = 0;
						branch = 0;
						mem_to_reg = 0;
						alu_op = 1;
						mem_write = 0;
						alu_src = 2'b10;
						reg_write = 1;
					end 
					else 
						if ((instruction[5:0] < 6'd8)) begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b11;
							reg_write = 1;
						end 
						else begin
							reg_dst = 1;
							jump = 0;
							branch = 0;
							mem_to_reg = 0;
							alu_op = 1;
							mem_write = 0;
							alu_src = 2'b00;
							reg_write = 1;
						end 
			end 
			6'd2: begin
				reg_dst = 0;
				jump = 1;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd4: begin
				reg_dst = 0;
				jump = 0;
				branch = 1;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
			6'd8: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd10: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd12: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd13: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd14: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd15: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd35: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 1;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b01;
				reg_write = 1;
			end 
			6'd43: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 1;
				alu_src = 2'b01;
				reg_write = 0;
			end 
			default: begin
				reg_dst = 0;
				jump = 0;
				branch = 0;
				mem_to_reg = 0;
				alu_op = 0;
				mem_write = 0;
				alu_src = 2'b00;
				reg_write = 0;
			end 
		endcase
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mem(clock,wen,raddr1,rdata1,raddr2,rdata2,waddr,wdata);
	parameter ADDR_SIZE = 4;
	parameter BYTE_SIZE = 8;
	input wire clock;
	input wire wen;
	input wire[(ADDR_SIZE - 1):0] raddr1;
	output wire[(BYTE_SIZE - 1):0] rdata1;
	input wire[(ADDR_SIZE - 1):0] raddr2;
	output wire[(BYTE_SIZE - 1):0] rdata2;
	input wire[(ADDR_SIZE - 1):0] waddr;
	input wire[(BYTE_SIZE - 1):0] wdata;
	reg[(BYTE_SIZE - 1):0] mem[((2 ** ADDR_SIZE) - 1):0];
	assign rdata1 = mem[raddr1];
	assign rdata2 = mem[raddr2];
	always @(posedge clock) if (wen) 
		mem[waddr] <= wdata;
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
module Mips32Yield(instr,raddr);
	input wire[31:0] instr;
	output wire[31:0] raddr;
	(*non_volatile*) reg[31:0] pc = 0;
	wire[31:0] pc_4;
	assign pc_4 = (pc + 4);
	assign raddr = (pc >> 2);
	wire reg_dst;
	wire jump;
	wire branch;
	wire mem_to_reg;
	wire alu_op;
	wire mem_write;
	wire[1:0] alu_src;
	wire c_reg_write;
	Control control(.instruction(instr),.reg_dst(reg_dst),.jump(jump),.branch(branch),.mem_to_reg(mem_to_reg),.alu_op(alu_op),.mem_write(mem_write),.alu_src(alu_src),.reg_write(c_reg_write));
	wire[4:0] shamt;
	assign shamt = instr[10:6];
	wire[31:0] imm;
	assign imm = {(instr[15] ? 16'b0000000000000001 : 16'b0000000000000000),instr[15:0]};
	wire[31:0] jump_addr;
	assign jump_addr = {pc_4[31:28],instr[25:0],2'b00};
	wire[31:0] branch_addr;
	assign branch_addr = (pc_4 + (imm << 2));
	wire[31:0] reg_read1;
	wire[31:0] reg_read2;
	wire[31:0] reg_write;
	Mem #(5,32) regs(.clock(clock.val),.wen(c_reg_write),.raddr1(instr[25:21]),.rdata1(reg_read1),.raddr2(instr[20:16]),.rdata2(reg_read2),.waddr((reg_dst ? instr[15:11] : instr[20:16])),.wdata(reg_write));
	wire[3:0] ctrl;
	AluControl alu_control(.alu_op(alu_op),.op(instr[31:26]),.ffield(instr[5:0]),.ctrl(ctrl));
	wire zero;
	wire[31:0] result;
	Alu alu(.ctrl(ctrl),.op1((alu_src[1] ? reg_read2 : reg_read1)),.op2((alu_src[1] ? (alu_src[0] ? reg_read1 : shamt) : (alu_src[0] ? imm : reg_read2))),.zero(zero),.result(result));
	wire[31:0] mem_read;
	Mem #(7,32) dmem(.clock(clock.val),.wen(mem_write),.raddr1((result >> 2)),.rdata1(mem_read),.waddr((result >> 2)),.wdata(reg_read2));
	assign reg_write = (mem_to_reg ? mem_read : result);
	always @(posedge clock.val) begin
		if ((instr[5:0] == 6'd13)) begin
			begin
				$__put(STDOUT,"%_",reg_read1);
				$fflush(STDOUT);
			end 
			$finish(0);
		end 
		if ((instr == 32'h114b0001)) begin
			$yield();
		end 
		if (jump) begin
			pc <= jump_addr;
		end 
		else 
			if ((branch & zero)) begin
				pc <= branch_addr;
			end 
			else begin
				pc <= pc_4;
			end 
	end 
endmodule
*** DECL_OK @ 0
*** PARSE @ 0
(*non_volatile*) reg[31:0] imem[63:0];
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] s = $fopen("share/cascade/test/benchmark/mips32/run_bubble_128_1024.hex","r");
*** ITEM_OK @ 0
*** PARSE @ 0
reg signed[31:0] i = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
reg[31:0] val = 0;
*** ITEM_OK @ 0
*** PARSE @ 0
initial begin
	for (i = 0; (i < 63); i = (i + 1)) begin
		$__get(s,"%u",val);
		imem[i] <= val;
	end 
end 
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] addr;
*** ITEM_OK @ 0
*** PARSE @ 0
wire[31:0] instr;
*** ITEM_OK @ 0
*** PARSE @ 0
assign instr = imem[addr];
*** ITEM_OK @ 0
*** PARSE @ 0
Mips32Yield mips32(.instr(instr),.raddr(addr));
*** ITEM_OK @ 0
